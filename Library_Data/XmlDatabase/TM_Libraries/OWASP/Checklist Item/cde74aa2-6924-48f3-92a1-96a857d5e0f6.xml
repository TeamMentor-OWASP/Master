<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="cde74aa2-6924-48f3-92a1-96a857d5e0f6" Author="" Category="Input and Data Validation" Priority="" Rule_Type="Checklist Item" Status="" Technology="ASP.NET 3.5" title="All the Input Is Validated For Length, Range, Format, And Type" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;What to Check For&lt;/h1&gt;&lt;p&gt;Check for input that is not passed through a validation routine. Validation routines should check for length, range, format, and type. Validation should check first&amp;nbsp;for known valid and safe data and then for malicious, dangerous data.&amp;nbsp; &lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities. Input validation on its own is not sufficient; output encoding is also needed to fully prevent these attacks.&lt;/p&gt;&lt;h1&gt;How to Check&lt;/h1&gt;&lt;p&gt;To check for this problem, use the following steps:&amp;nbsp;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Find all sources of input in your application.&lt;/strong&gt; During design time, identify all of the potential sources of input to your application. Scour the source code to discover sources of input that may have been missed in the design. Compile a list that you can use in the following steps.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Trace data from source to sink.&lt;/strong&gt; Trace each of source of input through your application until you find its ultimate destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a database.&amp;nbsp; &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify validation routines.&lt;/strong&gt; Each input source should have a data validation routine associated with it. Ideally the validation will occur as soon after the input reaches your application as possible. Shared validation routines are better than creating many spread throughout your code base, so check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If an input source does not have a validation routine associated with it, flag it for fixing.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ensure quality of validation routines.&lt;/strong&gt; Validation routines&amp;nbsp;should check for length, range, format, and type. Validation should check first&amp;nbsp;for known valid and safe data and then for malicious, dangerous data. Do not rely on filtering out all malicious data, as&amp;nbsp;it is too easy to miss something. Do not rely on client-side validation alone as it can be easily bypassed.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;How to Fix&lt;/h1&gt;&lt;p&gt;Check for known good data and constrain input by validating it for type, length, format, and range. For Web form applications that obtain input through server controls, use the ASP.NET validator controls, such as the RegularExpressionValidator, RangeValidator, and CustomValidator, to validate and constrain input. Check all numeric fields for type and range. If you are not using server controls, you can use regular expressions and the Regex class, and you can validate numeric ranges by converting the input value to an integer or double and then performing a range check.&amp;nbsp;Validate your input against the least permissive expression possible that will accept all the input you expect for that field. If you know that the field will have certain internal structure, check for it. If your input has an internal checksum, like a credit card number, check for&amp;nbsp;that too. &lt;/p&gt;&lt;p&gt;Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies.&amp;nbsp;Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input.&amp;nbsp;&lt;/p&gt;&lt;p&gt;The following example shows how to use the Regex class:&lt;/p&gt;&lt;pre&gt;using System.Text.RegularExpressions ;&lt;br&gt; // Instance method:Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");&lt;br&gt;Response.Write(reg.IsMatch(Request.QueryString["Name"]));&lt;br&gt;// Static method:&lt;br&gt;if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$"))&lt;br&gt; {&lt;br&gt;   // Name does not match expression&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons,&amp;nbsp;which helps&amp;nbsp;avoid unnecessary object creation. &lt;/p&gt;&lt;p&gt;Remember that validating input does not remove the need to format output, parameterize queries, or otherwise handle user input carefully. &lt;/p&gt;&lt;h1&gt;Problem Example&lt;/h1&gt;&lt;p&gt;An ASP.NET applcation contains an order form for a web store which has several fields, specifically, a name, address, phone number, item number, and quantity. Each item is simply added to the database, with any typecasting handled by the database. While casting to the appropriate type helps a little, it happens too late to prevent SQL injection issues. Furthermore, there are no guarantees about the quality of the data. &lt;/p&gt;&lt;h1&gt;Solution Example&lt;/h1&gt;&lt;p&gt;An ASP.NET application contains an order for for a web store. Each of the forms fields are validated, giving stronger guarantees about the data gathered.&amp;nbsp;The phone number&amp;nbsp;is validated as a string of ten digits (after stripping all non-numeric characters), or a variable number of digits beginning with the character '+' if international numbers are allowed.&amp;nbsp; &lt;/p&gt;&lt;p&gt;Validating a name, address, and item number can all be a bit more complicated.&amp;nbsp;The first order of business is determining the legal character set for each case. For names spaces, upper and lower case letters (including the accented forms for your current codepage), and possible numbers and periods are enough.&amp;nbsp;Addresses need to add commas, hyphens, and number signs, at a minimum.&amp;nbsp;Validating item numbers may be as simple as casting to an integer and checking that the result is in the right range, or it may mean a more complicated regular expression that checks for internal formatting in a string. &lt;/p&gt;&lt;p&gt;The last, optional step of data validation is to ensure that the data refers to a valid things.&amp;nbsp;The data should be validated for format first, especially as further checks may require database queries. Item numbers are an obvious thing to check for existence in the DB, and this would normally happen as part of the stored procedure which creates a new order, but names, addresses, and phone numbers can be similarly checked some times.&amp;nbsp;For example, if the address field is broken up into components, state or province information, zip/post codes, and city names, at a minimum, can all be validated against existing lists.&lt;/p&gt;&lt;br&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="ruledisplay:8a220644-4285-423d-9ebc-7f9069a038a5"&gt;Guideline: Validate Input from All Sources For Type, Length, Format, and Range&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;Adapted from Microsoft patterns &amp;amp; practices guidance.&lt;/p&gt;</content>
</guidanceItem>