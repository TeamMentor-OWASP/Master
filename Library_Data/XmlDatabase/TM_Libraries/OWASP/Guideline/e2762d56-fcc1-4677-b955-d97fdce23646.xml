<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="e2762d56-fcc1-4677-b955-d97fdce23646" Author="" Category="Input and Data Validation" Priority="2" Rule_Type="Guideline" Status="" Technology="Java" title="Filter All User-Supplied Filename And Path Input" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;p&gt;Applications written using Servlets or JSP.&lt;/p&gt;&lt;h1&gt;What to Do&lt;/h1&gt;&lt;p&gt;Carefully validate filename and path input. Apply whitelist techniques when validating input.&lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;Filenames and paths interact directly with the underlying filesystem. Allowing malicious users to manipulate file system operations directly or indirectly through their input can expose important sensitive system files. Canonicalization vulnerabilities can result in an attacker gaining access to unexpected resources.&lt;/p&gt;&lt;h1&gt;When&lt;/h1&gt;&lt;p&gt;If your user input is used to help construct filenames or file paths, carefully validate to ensure the input is not used to gain access to unexpected resources.&lt;/p&gt;&lt;h1&gt;How&lt;/h1&gt;&lt;p&gt;Use the following steps when validating filename and path input:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Establish a base directory. &lt;/strong&gt;The base directory is where your application should store any user-supplied files.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The location of the base directory should be carefully chosen. It should not be a subdirectory of any important directory such as &lt;strong&gt;/etc&lt;/strong&gt; or &lt;strong&gt;c:\windows&lt;/strong&gt;. &lt;/li&gt;&lt;li&gt;Write access should be allowed only to the base directory and its children, but not to its parents. &lt;/li&gt;&lt;li&gt;Because of read access misuses, it is recommended that no sensitive information is stored inside any of the base directory's parents. &lt;/li&gt;&lt;li&gt;Read/write access outside the base directory and its parents should be prohibited. This can be achieved via whitelist validation on the user-supplied filename and strict access control from the filesystem. &lt;/li&gt;&lt;li&gt;Avoid setting your application's local user account as owner of any of the base directory's parents.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Note:&lt;/strong&gt; If your application is Windows based, create your base directory in a partition different than the partition hosting all critical system services. Because Windows prohibits changing partitions through canonicalization, it is impossible for an attacker to access a resource that is located in another partition. For instance, if your Windows installation is located at &lt;strong&gt;c:\windows&lt;/strong&gt;, place your base directory at &lt;strong&gt;d:\myapp\temp&lt;/strong&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Validate using whitelisting. &lt;/strong&gt;The syntax for accessing filesystems is well known. Use whitelist techniques to allow good input and discard bad input. Be careful with canonicalization issues. Canonicalization problems occur when the user attempts to execute directory traversal by using special pathname sequences to direct your application into a directory it should not access. &lt;br&gt;&lt;br&gt;Example:&lt;br&gt;&lt;br&gt;Assume your application has created the file&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;d:\myapp\temp\file.dat&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;The following strings can also represent the same file:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;d:\myapp\temp\..\temp\file.datd:\myapp\temp\..\temp\..\temp\file.datd%3A%5Cmyapp%5Ctemp%5Cfile.dat&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;Canonicalization problems can be avoided by using whitelist techniques and setting the right permissions at the filesystem level. If your application knows the file structure within the base directory, the following code can be applied:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateFilename(File file) throws IOException, SecurityException&lt;br&gt;{&lt;br&gt;      // This represents the format d:\myapp\temp\&amp;lt;file name&amp;gt; where the file name&lt;br&gt;      // can consist of alpha-numeric, space/tab, period, and dash characters and&lt;br&gt;      // cannot exceed 20 characters in length&lt;br&gt;      String goodPattern = "d:(&lt;a&gt;\\\\|/)myapp(\\\\|/)temp(\\\\|/)(\\w|\\s|\\.|-|){1,20&lt;/a&gt;}";&lt;br&gt;      Pattern p = Pattern.compile(goodPattern, Pattern.CASE_INSENSITIVE);&lt;br&gt;      Matcher m = p.matcher(file.getCanonicalPath());&lt;br&gt;       if (!m.matches())&lt;br&gt;      {&lt;br&gt;            return false;&lt;br&gt;      }&lt;br&gt;       return true;&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;Filesystem permissions are also a very important mechanism for avoiding canonicalization problems. Restricting the access rights of your application's local account can prevent access to sensitive system data. It is recommended that:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;full access is given only within the base directory &lt;/li&gt;&lt;li&gt;read access is given only within the base directory's parents &lt;/li&gt;&lt;li&gt;no access is given anywhere else on the filesystem&lt;br&gt;&lt;br&gt;It is also recommended to execute your application with its own local account rather than as the hosting server; therefore, any restrictions applied to your application would not affect the performance of the hosting server. &lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Avoid common mistakes.&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use the Java File object.&lt;/strong&gt; Always use a &lt;strong&gt;java.io.File&lt;/strong&gt; object instead of a &lt;strong&gt;String&lt;/strong&gt; object to represent a file. Using the &lt;strong&gt;File&lt;/strong&gt; object allows you to access the actual file and some useful and relevant information such as the file's size, parent, path, etc. Example:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;File file = new File("d:\myapp\temp\file.dat");&lt;/pre&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Verify the canonical path.&lt;/strong&gt; The &lt;strong&gt;File&lt;/strong&gt; object provides the file's path in&amp;nbsp;three different forms -- original, absolute and canonical. Always use the canonical path when using whitelisting to verify the file's path. &lt;/p&gt;&lt;p&gt;For instance, the file &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;d:\myapp\temp\..\temp\..\temp\file.dat&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;would have the following paths:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;d:\myapp\temp\..\temp\..\temp\file.dat&lt;br&gt; (Original via the &lt;strong&gt;File.getPath&lt;/strong&gt; method)&lt;br&gt;d:\myapp\temp\..\temp\..\temp\file.dat&lt;br&gt; (Absolute via the &lt;strong&gt;File.getAbsolutePath&lt;/strong&gt; method)&lt;br&gt;D:\myapp\temp\file.dat&lt;br&gt; (Canonical via the &lt;strong&gt;File.getCanonicalPath&lt;/strong&gt; method)&lt;/pre&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Verify&amp;nbsp;that the filesystem is case-sensitive.&lt;/strong&gt; Always be sure&amp;nbsp;that your application's filesystem is case-sensitive. Because most UNIX based operating systems have case-sensitive filesystems, &lt;strong&gt;FILE.DAT&lt;/strong&gt; and &lt;strong&gt;file.dat&lt;/strong&gt; represent&amp;nbsp;two different files. However, Windows has a case-insensitive filesystem; therefore, &lt;strong&gt;FILE.DAT&lt;/strong&gt; and &lt;strong&gt;file.dat&lt;/strong&gt; represent the same file. If your application's filesystem is case-insensitive, make sure to specify the CASE_INSENSITIVE flag when using regular expressions to validate your file inputs. Example:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;String goodPattern = "d:(&lt;a&gt;\\\\|/)myapp(\\\\|/)temp(\\\\|/)(\\w|\\s|\\.|-|){1,20&lt;/a&gt;}";&lt;br&gt;Pattern p = Pattern.compile(goodPattern, Pattern.CASE_INSENSITIVE);&lt;/pre&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Verify the filesystem's path delimiters.&lt;/strong&gt; Verify the path delimiters that your application's filesystem uses and keep them consistent throughout the code. For example, Windows uses '&lt;strong&gt;\&lt;/strong&gt;' or '&lt;strong&gt;/&lt;/strong&gt;' to distinguish directories inside a path while UNIX based systems use only '&lt;strong&gt;/&lt;/strong&gt;' to accomplish the same task.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;Problem Example&lt;/h1&gt;&lt;p&gt;The following code allows the user to read the contents of a report file, located in &lt;strong&gt;/myapp/temp/&lt;/strong&gt;. Unfortunately, the code is missing filename validation; therefore, the application is exposed to a directory traversal attack:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;import java.io.*;&lt;br&gt;import java.util.*;&lt;br&gt;import java.lang.*;&lt;br&gt;import javax.servlet.*;&lt;br&gt;import javax.servlet.http.*;&lt;br&gt; public final class ReportDownloader extends HttpServlet&lt;br&gt;{&lt;br&gt;      public void doGet(HttpServletRequest request,&lt;br&gt;            HttpServletResponse response) throws ServletException, IOException&lt;br&gt;      {&lt;br&gt;            response.setContentType("application/vnd.ms-excel");&lt;br&gt;            String baseDir = "/myapp/temp/";&lt;br&gt;            PrintWriter out = response.getWriter();&lt;br&gt;            String filename = request.getParameter("file");&lt;br&gt;            BufferedReader fin;&lt;br&gt;            String data = "";&lt;br&gt;             try&lt;br&gt;            {&lt;br&gt;                  File reportFile = new File(baseDir + filename);&lt;br&gt;                  // The application fails to validate the user-supplied filename&lt;br&gt;                  fin = new BufferedReader(new FileReader(reportFile));&lt;br&gt;                  StringBuilder sb = new StringBuilder();&lt;br&gt;                  while (data != null)&lt;br&gt;                  {&lt;br&gt;                        data = fin.readLine();&lt;br&gt;                        if (validateData(data))&lt;br&gt;                        {&lt;br&gt;                              sb.append(data);&lt;br&gt;                        }&lt;br&gt;                        else&lt;br&gt;                        {&lt;br&gt;                              // Add the appropriate logging and exception handling&lt;br&gt;                              // mechanisms. Consult the Exception Handling and&lt;br&gt;                              // Logging sections&lt;br&gt;                              out.println("We cannot handle your request at the moment."&lt;br&gt;                                        + "Please try again later.");&lt;br&gt;                              return;&lt;br&gt;                        }&lt;br&gt;                  }&lt;br&gt;                  out.println(sb.toString());&lt;br&gt;            }&lt;br&gt;            catch (Exception e)&lt;br&gt;            {&lt;br&gt;                  // Add the appropriate logging and exception handling mechanisms&lt;br&gt;                  // Consult the Exception Handling and Logging sections&lt;br&gt;                  out.println("We cannot handle your request at the moment."&lt;br&gt;                            + "Please try again later.");&lt;br&gt;            }&lt;br&gt;             out.flush();&lt;br&gt;             out.close();&lt;br&gt;      }&lt;br&gt;       boolean validateData(String input)&lt;br&gt;      {&lt;br&gt;             // Implement a validation routine for the format of the reports&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Solution Example&lt;/h1&gt;&lt;p&gt;The following code allows the user to read the contents of a report file, located in &lt;strong&gt;/myapp/temp/&lt;/strong&gt;. Since the filename is validated, an attacker cannot execute directory traversal attacks. &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;import java.io.*;&lt;br&gt;import java.util.*;&lt;br&gt;import java.lang.*;&lt;br&gt;import javax.servlet.*;&lt;br&gt;import javax.servlet.http.*;&lt;br&gt; public final class ReportDownloader extends HttpServlet&lt;br&gt;{&lt;br&gt;      public void doGet(HttpServletRequest request,&lt;br&gt;            HttpServletResponse response) throws ServletException, IOException&lt;br&gt;      {&lt;br&gt;            response.setContentType("application/vnd.ms-excel");&lt;br&gt;            String baseDir = "/myapp/temp/";&lt;br&gt;            PrintWriter out = response.getWriter();&lt;br&gt;            String filename = request.getParameter("file");&lt;br&gt;            BufferedReader fin;&lt;br&gt;            String data = "";&lt;br&gt;             try&lt;br&gt;            {&lt;br&gt;                  File reportFile = new File(baseDir + filename);&lt;br&gt;                   // The application validates the user-supplied filename&lt;br&gt;                              if (validateFilename(reportFile))&lt;br&gt;                  {                        fin = new BufferedReader(new FileReader(reportFile));&lt;br&gt;                        StringBuilder sb = new StringBuilder();&lt;br&gt;                        while (data != null)&lt;br&gt;                        {&lt;br&gt;                              data = fin.readLine();&lt;br&gt;                              if (validateData(data))&lt;br&gt;                              {&lt;br&gt;&lt;br&gt;                                    sb.append(data);&lt;br&gt;                              }&lt;br&gt;                              else&lt;br&gt;                              {&lt;br&gt;                                    // Add the appropriate logging and exception&lt;br&gt;                                    // handling mechanisms. Consult the Exception&lt;br&gt;                                    // Handling and Logging sections&lt;br&gt;                                     out.println("We cannot handle your request at&lt;br&gt;                                               + "the moment. Please try again later.");&lt;br&gt;                                    return;&lt;br&gt;                              }&lt;br&gt;                        }&lt;br&gt;                        out.println(sb.toString());&lt;br&gt;                  }&lt;br&gt;                  else&lt;br&gt;                  {&lt;br&gt;                        // Add the appropriate logging and exception handling mechanisms&lt;br&gt;                        // Consult the Exception Handling and Logging sections&lt;br&gt;                        out.println("We cannot handle your request at the moment."&lt;br&gt;                                  + "Please try again later.");&lt;br&gt;                  }&lt;br&gt;            }&lt;br&gt;            catch (Exception e)&lt;br&gt;            {&lt;br&gt;                  // Add the appropriate logging and exception handling mechanisms&lt;br&gt;                  // Consult the Exception Handling and Logging sections&lt;br&gt;                   out.println("We cannot handle your request at the moment. "&lt;br&gt;                             + "Please try again later.");&lt;br&gt;            }&lt;br&gt;             out.flush();&lt;br&gt;            out.close();&lt;br&gt;      }&lt;br&gt;       boolean validateFilename(File file)&lt;br&gt;      {&lt;br&gt;            // This represents the format /myapp/temp/&amp;lt;filename&amp;gt;&lt;br&gt;            String goodPattern = "/myapp/temp/(\\w|\\s|\\.|-|){1,20}";&lt;br&gt;            Pattern p = Pattern.compile(goodPattern);&lt;br&gt;            Matcher m = p.matcher(file.getCanonicalPath());&lt;br&gt;            if (!m.matches())&lt;br&gt;            {&lt;br&gt;                  return false;&lt;br&gt;            }&lt;br&gt;            return true;&lt;br&gt;      }&lt;br&gt;       boolean validateData(String input)&lt;br&gt;      {&lt;br&gt;            // Implement a validation routine for the format of the reports&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Additional Resources&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;For more information on handling files with Java, see: Documentation for &lt;a href="http://download.oracle.com/javase/1.4.2/docs/api/java/io/File.html"&gt;Class File&lt;/a&gt; in Java SDK.&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559"&gt;Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43"&gt;Guideline: Validate Input from All Sources (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93"&gt;Guideline: Do Not Rely on Client-Side Validation (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:C7AC7D00-4AEA-4AFA-AD2D-1E812664BA38"&gt;Attack: Canonicalization Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF"&gt;Attack: Client-side Validation Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:42722D74-2F38-4B31-AC10-C9EC05DC7CC6"&gt;Attack: Alternate Data Streams Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D"&gt;Attack: Command Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:41BACAD4-8875-4F83-A9F6-C2263B23ABC4"&gt;Attack: File Name and Path Manipulation Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:351789B0-A694-4E05-9C05-1A53EF053AF7"&gt;Checklist Item: User-Supplied Filenames and Paths are Validated (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;</content>
</guidanceItem>