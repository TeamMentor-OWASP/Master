<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="616fda5d-4e96-4bc0-8675-954794f52557" Author="" Category="Input and Data Validation" Priority="2" Rule_Type="Guideline" Status="" Technology="ASP.NET 3.5" title="Validate All Input Passed to Database" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;What to Do&lt;/h1&gt;&lt;p&gt;Validate all input before it is passed to the database.&lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;Unvalidated input can lead to persistent cross-site scripting, SQL injection, and other vulnerabilities which would allow an attacker to gain unauthorized access to sensitive data.&lt;/p&gt;&lt;h1&gt;When&lt;/h1&gt;&lt;p&gt;If your application uses a backend database server.&lt;/p&gt;&lt;h1&gt;How&lt;/h1&gt;&lt;p&gt;To properly validate input passed to database:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify application inputs. &lt;/strong&gt;Potential sources of input include:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;URL based parameters &lt;/li&gt;&lt;li&gt;Form based parameters &lt;/li&gt;&lt;li&gt;Hidden fields &lt;/li&gt;&lt;li&gt;Cookies &lt;/li&gt;&lt;li&gt;Local filesystem &lt;/li&gt;&lt;li&gt;Javascript variables&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify database entry points.&lt;/strong&gt; Find all the locations in the system where data is pushed into the database, either directly via queries, or indirectly (via log entries, etc). Trace all database entry points to find all the paths which can contain external input.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create a set of validators:&lt;/strong&gt; Build a set of validators that work with the data in question and fit into the system architecture, including your general validation scheme for other data and the way the system interacts with the database. Using the &lt;a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909"&gt;Validate Input for Length, Range, Format, and Type&lt;/a&gt; guideline, determine the appropriate validation at each validator. Centralize the validators as it helps strengthen your code by limiting the amount of scattered validation code throughout the system, and allows for easy auditing. Place the validators along the database input paths, ideally as close to the initial data input as possible. All data should pass through the validators before breing transmitted to the database servers.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use Type-Safe parameters in SQL statements:&lt;/strong&gt; Stored procedures and Parameterized queries improve your application's robustness against SQL injection based attacks. Consult the guideline &lt;a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F"&gt;Use Type Safe SQL Parameters When Constructing SQL Queries&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Audit your entry paths.&lt;/strong&gt; Before going into production, have a reviewer who was not responsible for the development of the code in question check all the input paths to ensure that the validators are correctly implemented, that they are correctly applied, and that all input paths are checked.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;Problem Example&lt;/h1&gt;&lt;p&gt;The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.&lt;/p&gt;&lt;pre&gt;public boolean validateUser(String user, char[] pass)&lt;br&gt;{&lt;br&gt;      byte[] salt = MyApp.generateSalt();&lt;br&gt;      String passHash;&lt;br&gt;      SqlConnection cn;&lt;br&gt;      SqlCommand sqlCommand;&lt;br&gt;      String query;&lt;br&gt;      passHash = hashCredentials(pass, salt);&lt;br&gt;      // The application crafts the SQL query based on user's input&lt;br&gt;      cn = MyApp.getDBConnection();&lt;br&gt;      sqlCommand = new SqlCommand("select user from myappUsers where user = \""&lt;br&gt;&lt;br&gt;      + user + "\" and pass = \"" + passHash + "\" and login_attempts &amp;lt; 3;", cn);&lt;br&gt;      SqlDataReader reader = sqlCommand.ExecuteReader();&lt;br&gt;      updateLastLoginAttempt(user);&lt;br&gt;      ...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;If a user submits a login request with a username of 'foo\" or 1 = 1; drop table *; --', the system will happily first authenticate the user and then drop all the tables in the database.&lt;/p&gt;&lt;h1&gt;Solution Example&lt;/h1&gt;&lt;p&gt;The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Because the application uses the Parameters property, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection. &lt;/p&gt;&lt;pre&gt;public boolean validateUser(String user, char[] pass)&lt;br&gt;{&lt;br&gt;   byte[] salt = MyApp.generateSalt();&lt;br&gt;   String passHash; &lt;br&gt;   SqlConnection cn;&lt;br&gt;   SqlCommand sqlCommand;&lt;br&gt;   String query;     &lt;br&gt;   passHash = hashCredentials(pass, salt);&lt;br&gt;   // The application crafts the SQL query based on user's input&lt;br&gt;   cn = MyApp.getDBConnection();&lt;br&gt;   sqlCommand = new SqlCommand("select user from myappUsers where user = @user and &lt;br&gt;                    + pass = @passHash and login_attempts &amp;lt; 3;", cn);&lt;br&gt;   sqlCommand.Parameters.Add("@user", SqlDbType.VarChar, user.Length).Value = user;&lt;br&gt;   sqlCommand.Parameters.Add("@passHash ", SqlDbType.VarChar, passHash.Length).Value = passHash;&lt;br&gt;   SqlDataReader reader = sqlCommand.ExecuteReader(); &lt;br&gt;   updateLastLoginAttempt(user);  &lt;br&gt;   ...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Even if the user passes in an arbitrary string for a username or a password, they will not be able to alter the query or otherwise effect the database. An even better solution would involve using a stored procedure instead of a parameterized command, because that would permit the database to be locked down further.&lt;/p&gt;&lt;h1&gt;Additional Resources&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;To learn more about using regular expression for input validation, visit: &lt;a href="http://msdn2.microsoft.com/en-us/library/ms998267.aspx"&gt;How To: Use Regular Expressions to Constrain Input in ASP.NET&lt;/a&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F"&gt;Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909"&gt;Guideline: Validate Input for Length, Range, Format, and Type&amp;nbsp;&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:0FFC3880-7F2B-47A5-BC54-F9BD39117BDD"&gt;Guideline: Validate Input from All Sources &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F"&gt;Guideline: Use Stored Procedures &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764"&gt;Attack: SQL Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6"&gt;Attack: Server-Side Code Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:A61D6E7C-677C-463D-BB5D-7F36CAD4FF32"&gt;Checklist Item: All Database Input is Validated&lt;/a&gt; &lt;hr&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Adapted from Microsoft patterns &amp;amp; practices guidance. &lt;/p&gt;</content>
</guidanceItem>