<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="0ba54c5c-7064-4224-8d6d-b4906db5da59" Author="" Category="Data Access" Priority="2" Rule_Type="Guideline" Status="" Technology="Java" title="Use Type Safe SQL Parameters When Constructing SQL Queries" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Applications written using Servlets or JSP&amp;nbsp;that interact with a database.&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;What to Do&lt;/h1&gt;&lt;p&gt;Use Prepared Statements to execute SQL statements. Do not generate SQL statements directly from user input.&lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;Parameterized Queries mitigate the number one risk for database-facing Web applications: SQL injection. This powerful attack is language independent, as it depends on the algorithm used to generate SQL strings passed to the database and affects the database engine, not the actual application.&lt;/p&gt;&lt;p&gt;It exploits the creation of the SQL string, in which user input is embedded manually with escape sequences (such as the single quote (&lt;strong&gt;'&lt;/strong&gt;) or double quote (&lt;strong&gt;"&lt;/strong&gt;) characters). Using this method, an attacker inserts valid SQL statement fragments as part of user input so they, in turn, are embedded within the SQL query that is submitted to the database engine for execution. Successful exploitation allows an attacker to potentially compromise the entire database and often the underlying operating system. &lt;/p&gt;&lt;p&gt;Parameterized Queries offer a simple yet efficient mitigation since they automatically contain user-input in a non-escaped form, "compiling" the query and passing the input as parameters, much like a function call. There is no known method of injecting custom SQL over Parameterized Queries.&lt;/p&gt;&lt;p&gt;Additionally, using Parameterized queries offers two significant advantages:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Greater Efficiency&lt;/strong&gt;: The database engine needs to "compile" the statement only once, allowing for greater efficiency in query invocation. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Greater Security&lt;/strong&gt;: The database engine automatically handles the parsing and embedding of user input, effectively negating any potential for SQL injection due to attackers taking advantage of delimiter characters such as a single quote (&lt;strong&gt;'&lt;/strong&gt;) or a double quote (&lt;strong&gt;"&lt;/strong&gt;). &lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;When&lt;/h1&gt;&lt;p&gt;Type-safe SQL parameters should be used whenever SQL statements need to be executed by the database. &lt;/p&gt;&lt;h1&gt;How&lt;/h1&gt;&lt;p&gt;One way of making the application less susceptible to SQL injection attacks is by using stored procedures. Stored procedures are subroutines stored in the database that are available to applications for accessing the data. &lt;/p&gt;&lt;p&gt;Just using stored procedures isn't a complete remedy for SQL injection. The important thing to do is use parameters with stored procedures, or else your stored procedures can be susceptible to SQL injection if they use unfiltered input. Stored procedures provide several security advantages: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;By parameterizing input parameters and type-enforcing them, user input is effectively filtered. &lt;/li&gt;&lt;li&gt;Stored procedures are allowed by most databases&amp;nbsp;to execute under different security privileges than&amp;nbsp;from the database user, thereby restricting the ability of the application to do anything beyond the actions specified in the stored procedures. For instance, an application would have execute access to a stored procedure but no access to the base tables. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To use type-safe SQL parameters, follow these steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;If possible, use stored procedures. &lt;/strong&gt;Stored procedures are pre-compiled statements that are stored on the database server. Using stored procedures improves your application's performance and security. Consult the &lt;a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662"&gt;Use Stored Procedures&lt;/a&gt; guideline for more details.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify the SQL queries. &lt;/strong&gt;Locate all SQL queries throughout your application. Example:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;Connection cn = MyApp.getDBConnection();&lt;br&gt;Statement st = cn.createStatement();&lt;br&gt;String query = "select login_attempts from myappUsers where user = \"" + user&lt;br&gt;             + "\" and pass = \"" + new String(passDigest) + "\";";&lt;br&gt;ResultSet rs = st.executeQuery(query);&lt;/pre&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify the parameters in each SQL query. &lt;/strong&gt;After locating all SQL queries, identify the parameters in each query. Understand the format and type of each parameter's data.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use PreparedStatement. &lt;/strong&gt;Java supports parameterized queries via its &lt;strong&gt;PreparedStatement&lt;/strong&gt; class. &lt;strong&gt;PreparedStatement&lt;/strong&gt; is mapped by most databases to a parameterized query or a stored procedure. Although the implementation may differ&amp;nbsp;among databases, the functionality is the same. Turn all SQL queries into parameterized queries. To accomplish this, turn all &lt;strong&gt;Statement&lt;/strong&gt; objects into &lt;strong&gt;PreparedStatement&lt;/strong&gt; objects. For example, the SQL query from Step 1 would be:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;Connection cn = MyApp.getDBConnection();&lt;br&gt;PreparedStatement st = cn.prepareStatement("select login_attempts from myappUsers"&lt;br&gt;                     + " where user = ? and pass = ?;");&lt;br&gt;st.setString(1, user);&lt;br&gt;st.setString(2, new String(passDigest));&lt;br&gt;ResultSet rs = st.executeQuery();&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;For more information, consult the documentation for &lt;a href="http://java.sun.com/j2se/1.4.2/docs/api/java/sql/PreparedStatement.html"&gt;Class PreparedStatement&lt;/a&gt; in the Java SDK.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;Problem Example&lt;/h1&gt;&lt;p&gt;The following code validates the user based on a given username and password. It hashes the password with a random salt, then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateUser(String user, char[] pass)&lt;br&gt;{&lt;br&gt;      // Hash the credentials before querying the credential store&lt;br&gt;      // The application crafts the SQL query based on user's input&lt;br&gt;      Connection cn = MyApp.getDBConnection();&lt;br&gt;      Statement st = cn.createStatement();&lt;br&gt;      String query = "select login_attempts from myappUsers where user = \""&lt;br&gt;                    + user + "\" and pass = \"" + passHash + "\";";&lt;br&gt;      ResultSet rs = st.executeQuery(query);&lt;br&gt;       // Execute the rest of the authentication steps&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Solution Example&lt;/h1&gt;&lt;p&gt;The following code validates the user based on given username and password. It hashes the password with a random salt, then it compares the username and the produced hash against the data stored in the backend database. Because the application uses &lt;strong&gt;PreparedStatement&lt;/strong&gt;, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection. &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateUser(String user, char[] pass)&lt;br&gt;{&lt;br&gt;      // Hash the credentials before querying the credential store&lt;br&gt;      // The application uses parameterized queries&lt;br&gt;      Connection cn = MyApp.getDBConnection();&lt;br&gt;      PreparedStatement st = cn.prepareStatement("select user from myappUsers"&lt;br&gt;                            + " where user = ? and pass = ?;");&lt;br&gt;      st.setString(1, user);&lt;br&gt;      st.setString(2, passHash);&lt;br&gt;      ResultSet rs = st.executeQuery();&lt;br&gt;       // Execute the rest of the authentication steps&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Additional Resources&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;To learn more about using parameterized queries in Java, see: Documentation for &lt;a href="http://java.sun.com/j2se/1.4.2/docs/api/java/sql/PreparedStatement.html"&gt;Interface PreparedStatement&lt;/a&gt;. &lt;/li&gt;&lt;li&gt;For more information about preventing SQL injection attacks, visit: &lt;a href="http://www.owasp.org/index.php/Reviewing_Code_for_SQL_Injection"&gt;Reviewing Code for SQL Injection&lt;/a&gt; from OWASP. &lt;/li&gt;&lt;li&gt;To learn more about SQL server security, visit: &lt;a href="http://www.sqlsecurity.com/"&gt;SQLSecurity.com&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662"&gt;Guideline: Use Stored Procedures (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:81491E66-67B7-49F3-BDA6-4B4C9245C702"&gt;Guideline: Validate All Input Passed to Database (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:D089D9CA-860C-4F98-BC7E-5AD7553DB6DD"&gt;Checklist Item: Client-Side Validation is Not Relied On (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:AA3B4801-99BA-43B0-90A6-D38A605E8574"&gt;Checklist Item: Type Safe SQL Parameters are Used (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6"&gt;Attack: Server-Side Code Injection Attack&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content>
</guidanceItem>