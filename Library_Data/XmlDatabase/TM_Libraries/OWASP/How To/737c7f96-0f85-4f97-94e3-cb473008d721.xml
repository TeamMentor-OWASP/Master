<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="737c7f96-0f85-4f97-94e3-cb473008d721" Author="" Category="Input and Data Validation" Priority="" Rule_Type="How To" Status="" Technology="Java" title="How to Test for Path Manipulation Bugs in Java" Topic="Security" phase="Test" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;J2EE applications&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;In a path manipulation attack, an attacker submits input to alter an internal file path used by the application, forcing the application to use a malicious path. Attackers may exploit this bug to read sensitive files on the server, such as configuration files or another user’s files, or to modify or delete server-side files. &lt;/p&gt;&lt;p&gt;Follow these steps to test for path manipulation bugs in J2EE:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1: Understand attack scenarios &lt;/li&gt;&lt;li&gt;Step 2: Analyze causes and countermeasures &lt;/li&gt;&lt;li&gt;Step 3: Start testing and exploring &lt;/li&gt;&lt;li&gt;Step 4: Execute additional testing&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Step 1: Understand Attack Scenarios&lt;/h1&gt;&lt;p&gt;The first step in testing for path manipulation bugs is to understand the anatomy of an attack scenario. &lt;/p&gt;&lt;p&gt;To exploit this vulnerability, the attacker manipulates a file path in an HTTP request. If the application is vulnerable, it uses the manipulated file path to perform a file system operation.&lt;/p&gt;&lt;p&gt;The attack starts with the attacker discovering an HTTP request that invokes a server-side file system operation such as reading, modifying, deleting, emailing, or printing a file. This request comes either from a Web page or from a client-side script (such as in AJAX applications) and contains a variable (URL parameter, Web form input, etc) that the server uses to determine what file to handle.&lt;/p&gt;&lt;p&gt;To execute the attack, the attacker submits the request but modifies this variable in an attempt to manipulate a server-side file. If the attack is successful, the value provided by the attacker causes the server to access a file in a different path. In most cases, the attacker will be able to tell if the attack is successful shortly after executing it.&lt;/p&gt;&lt;p&gt;The steps are then:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The attacker finds an HTTP request that invokes a file system operation at the server. &lt;/li&gt;&lt;li&gt;The attacker locates a variable in&amp;nbsp;that HTTP request that is used to determine the path for a file system operation. &lt;/li&gt;&lt;li&gt;The attacker submits the request but modifies the path-determining variable and waits for a server response. &lt;/li&gt;&lt;li&gt;The attacker verifies if the attack is successful by observing the server’s response. &lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;em&gt;&lt;br&gt;Attack Variants&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Attackers can employ path manipulation attacks to achieve different threats. For example, an attacker can manipulate a path to read server configuration and password files or to read files belonging to another user in order to &amp;nbsp;execute an information disclosure attack on the application. Similarly, an attacker can manipulate a path to force the J2EE application to delete a file needed to properly service its users, thus generating a denial of service situation.&lt;/p&gt;&lt;h1&gt;Step 2: Analyze Causes and Countermeasures&lt;/h1&gt;&lt;p&gt;Before executing practical test cases, it is necessary to understand why these bugs exist and how to avoid them.&lt;/p&gt;&lt;p&gt;Path manipulation bugs are caused by J2EE applications that use client-supplied input to build a file path without properly validating the input. For instance, the code below gets an input value from the user in a URL parameter named &lt;em&gt;filename&lt;/em&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;PrintWriter out = response.getWriter();&lt;br&gt;&amp;nbsp;&lt;br&gt;String filename = "/public/user_files/" + request.getParameter("filename").toString();&lt;br&gt;&amp;nbsp;&lt;br&gt;File file = new File(filename);&lt;br&gt;FileReader fr = new FileReader(file);&lt;br&gt;BufferedReader br = new BufferedReader(fr);&lt;br&gt;String line = br.readLine();&lt;br&gt;while ( line != null )&lt;br&gt;{&lt;br&gt;  out.println(line);&lt;br&gt;&amp;nbsp;&amp;nbsp;   line = br.readLine();&lt;br&gt;}&lt;br&gt;fr.close();&lt;br&gt;out.close();&lt;/pre&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt;If the user provides an expected file name such as &lt;em&gt;file.txt&lt;/em&gt;, the application returns an expected user file:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;http://example.com.pe/example/getFile?filename=&lt;strong&gt;file.txt&lt;/strong&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;However, in a path manipulation scenario, an attacker provides a malicious value for the variable, hoping that the application uses it to determine a different file path:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;http://example.com.pe/example/getFile?filename=&lt;strong&gt;../../private/secret.txt&lt;/strong&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The string above causes the application to go up two directories, navigate to the &lt;em&gt;private&lt;/em&gt; folder, and display &lt;em&gt;secret.txt.&lt;/em&gt; The example above is a common scenario in information disclosure due to path manipulation. Notice that the attack is possible because the code shown trusts the filename provided by the client; it starts by directly copying the input to the internal variable used to determine the filename without properly validating it.&lt;/p&gt;&lt;p&gt;To protect against this bug, J2EE applications must properly validate user input. Specifically, they must check if the input is safe to use in determining a file path. Developers can use blacklists that contain a list of all disallowed filename constructs such as &lt;strong&gt;../&lt;/strong&gt; and check if the user input appears in the blacklist. The problem with blacklists is that blacklists must account for 100% of attack variants to be effective. Any variant of an attack that is not accounted for will execute unnoticed.&lt;/p&gt;&lt;p&gt;As such, the recommended approach for defending against this bug is to use &lt;em&gt;whitelists. &lt;/em&gt;Whitelists specify only safe constructs, and disallow any user input that doesn’t match any of the specified safe constructs. By doing this, they only need to specify what is good and don’t have to worry about accounting 100% of all attack variants. A common way of implementing a whitelist is by using a regular expression to specify what is safe and to disallow all input that doesn’t match the regular expression:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;String input = request.getParameter("filename").toString();&lt;br&gt;&amp;nbsp;&amp;nbsp; &lt;br&gt;String safeConstruct = "^[a-zA-Z]{4,8}\.txt$";&lt;br&gt;Pattern regexPattern = Pattern.compile(safeConstruct);&lt;br&gt;Matcher regexMatcher = regexPattern.matcher(input);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;if (!regexMatcher.find())&lt;br&gt;{&lt;br&gt;  out.println("invalid input");&lt;br&gt;}&lt;br&gt;else&amp;nbsp; &lt;br&gt;{&lt;br&gt;  String filename = "/public/user_files/" + input; &lt;br&gt;&amp;nbsp;  File file = new File(filename);&lt;br&gt;  &amp;nbsp;&lt;br&gt;  /* continue reading file */&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;The input must consist of four to eight consecutive upper- or lower-case letters followed by the extension &lt;strong&gt;.txt&lt;/strong&gt;. Any input that doesn’t match this form results in the application giving an &lt;em&gt;invalid input&lt;/em&gt; error.&lt;/p&gt;&lt;h1&gt;Step 3: Start Testing and Exploring&lt;/h1&gt;&lt;p&gt;Now that you’ve learned the common attack scenarios as well as the causes and countermeasures for path manipulation bugs, it is necessary to execute basic test cases to check if your application is vulnerable.&lt;/p&gt;&lt;p&gt;Success in testing for path manipulation bugs depends on your ability to determine what variables the application uses to build a file path. Applications commonly use URL and Web form variables, so it is necessary to understand how to test through these two input points. &lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for path manipulation in URL variables&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these steps to test for path manipulation in an URL variable:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Use an Internet browser to perform a file system operation. Note the URL used, such as: &lt;em&gt;http://example.com.pe/example.jsp?&lt;strong&gt;page=index.html&lt;/strong&gt;&lt;/em&gt;. &lt;/li&gt;&lt;li&gt;Locate the URL variable used to by the application to determine the file name (in this case it is &lt;em&gt;page&lt;/em&gt;). &lt;/li&gt;&lt;li&gt;Replace the value of the variable found in Step 2 with an attack string (see Table 1 below). For instance: &lt;em&gt;http://example.com.pe/example.jsp?page&lt;strong&gt;=&lt;/strong&gt;../../../etc/passwd&lt;/em&gt;. &lt;/li&gt;&lt;li&gt;Submit the request to the application and wait for a response.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in Step 3 to determine the response, and the attacker-specified file is used in the response.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for path manipulation in Web form variables&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these steps to test for path manipulation through Web forms:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Navigate to a page containing a Web form that prompts for a file name. &lt;/li&gt;&lt;li&gt;Locate the variable (input field) used by the application to determine the file name. &lt;/li&gt;&lt;li&gt;Enter the attack string in the field that indicates the filename (see Table 1 below).&lt;br&gt;Here, it is important to disable any client-side checks that may deny entering an attack string due to illegal characters. For more information, see &lt;a href="ruledisplay:fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f"&gt;How to Test for Client-Side Validation Bypass Bugs in Java&lt;/a&gt;. &lt;/li&gt;&lt;li&gt;Submit the request to the application and wait for a response.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results are the same as the previous test case: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in Step 3 to determine the response, and the attacker-specified file is used in the response.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Attack strings&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;The following attack strings contain path manipulation characters (dots, slashes, and backslashes) and common UNIX- and Windows-related file paths in different encodings. Depending on the relative location of the Web application on the server, the number of “../” or “..\” clauses may need to be increased or decreased to realize an attack:&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;../etc/passwd&lt;br&gt;..\boot.ini&lt;br&gt;../boot.ini&lt;br&gt;folder_name/file_name&lt;br&gt;..\..\folder_name\file_name&lt;br&gt;../../folder_name/file_name&lt;br&gt;C:\boot.ini&lt;br&gt;%2e%2e\%2e%2e\&lt;br&gt;..%2f..%2f&lt;br&gt;%2e%2e%2f%2e%2e%2ffolder_name%2ffile_name&lt;br&gt;..%2f..%2ffolder_name%2ffile_name&lt;br&gt;..%c0%af..%c0%affolder_name..%c0%affile_name &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&amp;nbsp;&lt;strong&gt;Table 1 - Path Manipulation Attack Strings&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Look for error messages that indicate file operations&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;While executing the basic test cases mentioned above, it is important to look for different types of error messages. For instance, “invalid input” or “incorrect format” error messages indicate that an application is safe, while “file not found” or HTTP 404 errors indicate that the application may be using the attack string to find a file in a different path, and may be vulnerable to this bug.&lt;/p&gt;&lt;h1&gt;Step 4: Execute Additional Testing&lt;/h1&gt;&lt;p&gt;Finally, it is important to execute additional testing for double encoding scenarios as well as to cover all of the application’s input points.&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1&gt;&lt;em&gt;Cover double encoding scenarios&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;Since this attack requires passing malicious input to a Web application, it is necessary for proper coverage to add double encoding test cases. Double encoding consists of re-encoding the percent sign (%) in percent-encoded values with its percent-encoded equivalent (%25). For instance, translating the first URL into the second one:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;../../&amp;nbsp; (no encoding)&lt;/pre&gt;&lt;pre&gt;..%2f..%2f&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (single encoding)&lt;/pre&gt;&lt;pre&gt;..%252f..%252f (double encoding)&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;Make sure to add a double-encoded test case for every attack string that you use. For more information about double encoding attacks, see &lt;a href="ruledisplay:5c99da7b-b4eb-4315-b48c-ac2598c13144"&gt;How to Test for Double Encoding Bugs in Java&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test through all input points&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Even though path manipulation attacks commonly happen through the URL or Web forms, it is important to look at additional application input points. Web applications can also take input from client cookies, Web methods, extended frameworks (such as Flash/Flex), and third-party APIs (such as Facebook) parameters. Make sure to test for path manipulation in every place where input is taken.&lt;/p&gt;&lt;h1&gt;Conclusions&lt;/h1&gt;&lt;p&gt;Path manipulation bugs allow attackers to access a server-side file to execute attacks such as information disclosure and denial of service. They&amp;nbsp;can be&amp;nbsp;successful when applications don’t properly validate user input against a whitelist and allow path manipulating characters such as dots and slashes to be processed by the application. To test for this vulnerability, you must identify the file path determining variable, commonly sent in the URL or in a Web form, and replace it with an attack string while looking for an error message that indicates that the attack string is being used. Finally, to achieve proper test coverage of this bug, be sure to cover double encoding scenarios and test through all of the application’s input points.&lt;/p&gt;</content>
</guidanceItem>