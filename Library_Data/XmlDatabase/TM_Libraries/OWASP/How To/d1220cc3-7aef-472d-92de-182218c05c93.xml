<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="d1220cc3-7aef-472d-92de-182218c05c93" Author="" Category="Input and Data Validation" Priority="" Rule_Type="How To" Status="" Technology="ASP.NET 3.5" title="How to Protect From SQL Injection in ASP.NET" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;This How to shows a number of ways to help protect your ASP.NET application from SQL injection attacks. SQL injection can occur when an application uses input to construct dynamic SQL statements or when it uses stored procedures to connect to the database. Conventional security measures, such as the use of SSL and IPSec, do not protect your application from SQL injection attacks. Successful SQL injection attacks enable malicious users to execute commands in an application's database.&lt;/p&gt;&lt;p&gt;Countermeasures include using a list of acceptable characters to constrain input, using parameterized SQL for data access, and using a least privileged account that has restricted permissions in the database. Using stored procedures with parameterized SQL is the recommended approach because SQL parameters are type safe. Type-safe SQL parameters can also be used with dynamic SQL. In situations where parameterized SQL cannot be used, consider using character escaping techniques. &lt;/p&gt;&lt;h1&gt;Contents&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;div&gt;Objectives&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Overview&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Summary of Steps&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Step 1. Constrain Input&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Step 2. Use Parameters with Stored Procedures&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Step 3. Use Parameters with Dynamic SQL&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Additional Considerations&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;Additional Resources&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Objectives&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Learn how SQL injection attacks work. &lt;/li&gt;&lt;li&gt;Constrain input to prevent SQL injection. &lt;/li&gt;&lt;li&gt;Use type safe SQL command parameters to prevent SQL injection. &lt;/li&gt;&lt;li&gt;Use a least privileged account to connect to the database. &lt;/li&gt;&lt;li&gt;Learn additional countermeasures to further reduce risk. &lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Overview&lt;/h1&gt;&lt;p&gt;A successful SQL injection attack enables a malicious user to execute commands in your application's database by using the privileges granted to your application's login. The problem is more severe if your application uses an over-privileged account to connect to the database. For example, if your application's login has privileges to eliminate a database, then without adequate safeguards, an attacker might be able to perform this operation.&lt;/p&gt;&lt;p&gt;Common vulnerabilities that make your data access code susceptible to SQL injection attacks include: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Weak input validation. &lt;/li&gt;&lt;li&gt;Dynamic construction of SQL statements without the use of type-safe parameters. &lt;/li&gt;&lt;li&gt;Use of over-privileged database logins. &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;SQL Injection Example&lt;/h2&gt;&lt;p&gt;Consider what happens when a user types the following string in the &lt;strong&gt;SSN&lt;/strong&gt; text box, which is expecting a Social Security number of the form &lt;em&gt;nnn-nn-nnnn&lt;/em&gt;.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;' ; DROP DATABASE pubs  --  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using the input, the application executes the following dynamic SQL statement or stored procedure, which internally executes a similar SQL statement. &lt;/p&gt;&lt;div&gt;&lt;pre&gt;// Use dynamic SQL&lt;br&gt;SqlDataAdapter myCommand = new SqlDataAdapter(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "SELECT au_lname, au_fname FROM authors WHERE au_id = '" + &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SSN.Text + "'", myConnection);&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;// Use stored procedures&lt;br&gt;SqlDataAdapter myCommand = new SqlDataAdapter(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "LoginStoredProcedure '" + &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SSN.Text + "'", myConnection);&lt;br&gt;&lt;/pre&gt;&lt;p&gt;The developer's intention was that when the code runs, it inserts the user's input and generates a SQL the following statement.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;SELECT au_lname, au_fname FROM authors WHERE au_id = '172-32-9999'  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, the code inserts the user's malicious input and generates the following query.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;SELECT au_lname, au_fname FROM authors WHERE au_id = ''; DROP DATABASE pubs --'  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, the &lt;strong&gt;'&lt;/strong&gt; (single quotation mark) character that starts the rogue input terminates the current string literal in the SQL statement. It closes the current statement only if the following parsed token does not make sense as a continuation of the current statement but does make sense as the start of a new statement. As a result, the opening single quotation mark character of the rogue input results in the following statement.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;SELECT au_lname, au_fname FROM authors WHERE au_id = ''  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The&lt;strong&gt;;&lt;/strong&gt; (semicolon) character tells SQL that this is the end of the current statement, which is then followed by the following malicious SQL code.&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;a class="copyCode" href="javascript:CopyCode('ctl00_LibFrame_ctl09');"&gt;&lt;/a&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;pre&gt;; DROP DATABASE pubs  &lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;strong&gt;Note&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;The semicolon is not necessarily required to separate SQL statements. This is dependent on vendor or implementation, but Microsoft SQL Server does not require them. For example, SQL Server parses the following as two separate statements:&lt;/blockquote&gt;&lt;blockquote&gt;SELECT * FROM MyTable DELETE FROM MyTable&lt;/blockquote&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;p&gt;Finally, the &lt;strong&gt;--&lt;/strong&gt; (double dash) sequence of characters is a SQL comment that tells SQL to ignore the rest of the text. In this case, SQL ignores the closing &lt;strong&gt;'&lt;/strong&gt; (single quotation mark) character, which would otherwise cause a SQL parser error.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;--'  &lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;Guidelines&lt;/h2&gt;&lt;p&gt;To counter SQL injection attacks, you need to: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Constrain and sanitize input data. &lt;/strong&gt;Check for known good data by validating for type, length, format, and range. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Use type-safe SQL parameters for data access.&lt;/strong&gt; You can use these parameters with stored procedures or dynamically constructed SQL command strings. Parameter collections such as &lt;strong&gt;SqlParameterCollection&lt;/strong&gt; provide type checking and length validation. If you use a parameters collection, input is treated as a literal value, and SQL Server does not treat it as executable code. An additional benefit of using a parameters collection is that you can enforce type and length checks. Values outside of the range trigger an exception. This is a good example of defense in depth. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Use an account that has restricted permissions in the database.&lt;/strong&gt; Ideally, you should only grant execute permissions to selected stored procedures in the database and provide no direct table access. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Avoid disclosing database error information. &lt;/strong&gt;In the event of database errors, make sure you do not disclose detailed error messages to the user. &lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;strong&gt;Note&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Conventional security measures, such as the use of Secure Socket Layer (SSL) and IP Security (IPSec), do not protect your application from SQL injection attacks. &lt;/blockquote&gt;&lt;h1&gt;Summary of Steps&lt;/h1&gt;&lt;p&gt;To protect your application from SQL injection, perform the following steps: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1. Constrain input. &lt;/li&gt;&lt;li&gt;Step 2. Use parameters with stored procedures. &lt;/li&gt;&lt;li&gt;Step 3. Use parameters with dynamic SQL.&lt;strong&gt; &lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Step 1. Constrain Input&lt;/h1&gt;&lt;p&gt;You should validate all input to your ASP.NET applications for type, length, format, and range. By constraining the input used in your data access queries, you can protect your application from SQL injection. &lt;/p&gt;&lt;blockquote&gt;&lt;strong&gt;Note&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;When constraining input, it is a good practice to create a list of acceptable characters and use regular expressions to reject any characters that are not on the list. The potential risk associated with using a list of unacceptable characters is that it is always possible to overlook an unacceptable character when defining the list; also, an unacceptable character can be represented in an alternate format to pass validation. &lt;/blockquote&gt;&lt;h2&gt;Constrain Input in ASP.NET Web Pages&lt;/h2&gt;&lt;p&gt;Start by constraining input in the server-side code for your ASP.NET Web pages. Do not rely on client-side validation because it can be easily bypassed. Use client-side validation only to reduce round trips and to improve the user experience.&lt;/p&gt;&lt;p&gt;If you use server controls, use the ASP.NET validator controls, such as the &lt;strong&gt;RegularExpressionValidator&lt;/strong&gt; and &lt;strong&gt;RangeValidator&lt;/strong&gt; controls to constrain input. If you use regular HTML input controls, use the &lt;strong&gt;Regex&lt;/strong&gt; class in your server-side code to constrain input.&lt;/p&gt;&lt;p&gt;If in the previous code example, the SSN value is captured by an ASP.NET &lt;strong&gt;TextBox&lt;/strong&gt; control, you can constrain its input by using a &lt;strong&gt;RegularExpressionValidator&lt;/strong&gt; control as shown in the following.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;&amp;lt;%@ language="C#" %&amp;gt;&lt;br&gt;&amp;lt;form id="form1" runat="server"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;asp:TextBox ID="SSN" runat="server"/&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;asp:RegularExpressionValidator ID="regexpSSN" runat="server"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ErrorMessage="Incorrect SSN Number" &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ControlToValidate="SSN"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ValidationExpression="^\d{3}-\d{2}-\d{4}$" /&amp;gt;&lt;br&gt;&amp;lt;/form&amp;gt;  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the SSN input is from another source, such as an HTML control, a query string parameter, or a cookie, you can constrain it by using the &lt;strong&gt;Regex&lt;/strong&gt; class from the &lt;strong&gt;System.Text.RegularExpressions&lt;/strong&gt; namespace. The following example assumes that the input is obtained from a cookie.&lt;/p&gt;&lt;p&gt;using System.Text.RegularExpressions;&lt;/p&gt;&lt;div&gt;&lt;pre&gt;if (Regex.IsMatch(Request.Cookies["SSN"], "^\d{3}-\d{2}-\d{4}$"))&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // access the database&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // handle the bad input&lt;br&gt;}  &lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;Constrain Input in Data Access Code&lt;/h2&gt;&lt;p&gt;In some situations, you need to provide validation in your data access code, perhaps in addition to your ASP.NET page-level validation. Two common situations where you need to provide validation in your data access code are: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Untrusted clients.&lt;/strong&gt; If the data can come from an untrusted source or you cannot guarantee how well the data has been validated and constrained, add validation logic that constrains input to your data access routines. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Library code. &lt;/strong&gt;If your data access code is packaged as a library designed for use by multiple applications, your data access code should perform its own validation, because you can make no safe assumptions about the client applications. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The following example shows how a data access routine can validate its input parameters by using regular expressions prior to using the parameters in a SQL statement.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;using System;&lt;br&gt;using System.Text.RegularExpressions;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;public void CreateNewUserAccount(string name, string password)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Check name contains only lower case or upper case letters, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // the apostrophe, a dot, or white space. Also check it is &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // between 1 and 40 characters long&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if ( !Regex.IsMatch(userIDTxt.Text, @"^[a-zA-Z'./s]{1,40}$"))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; throw new FormatException("Invalid name format");&lt;/pre&gt;&lt;pre&gt;&amp;nbsp;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Check password contains at least one digit, one lower case &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // letter, one uppercase letter, and is between 8 and 10 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // characters long&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if ( !Regex.IsMatch(passwordTxt.Text, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; @"^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$" ))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; throw new FormatException("Invalid password format");&lt;/pre&gt;&lt;pre&gt;&amp;nbsp;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Perform data access logic (using type safe parameters)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ...&lt;br&gt;}&lt;/pre&gt;&lt;h1&gt;Step 2. Use Parameters with Stored Procedures&lt;/h1&gt;&lt;p&gt;Using stored procedures does not necessarily prevent SQL injection. The important thing to do is use parameters with stored procedures. If you do not use parameters, your stored procedures can be susceptible to SQL injection if they use unfiltered input as described in the "Overview" section of this document.&lt;/p&gt;&lt;p&gt;The following code shows how to use &lt;strong&gt;SqlParameterCollection&lt;/strong&gt; when calling a stored procedure.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;using System.Data;&lt;br&gt;using System.Data.SqlClient;&lt;/pre&gt;&lt;pre&gt;using (SqlConnection connection = new SqlConnection(connectionString))&lt;br&gt;{&lt;br&gt;&amp;nbsp; DataSet userDataset = new DataSet();&lt;br&gt;&amp;nbsp; SqlDataAdapter myCommand = new SqlDataAdapter( &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "LoginStoredProcedure", connection);&lt;br&gt;&amp;nbsp; myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;&lt;br&gt;&amp;nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);&lt;br&gt;&amp;nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp; myCommand.Fill(userDataset);&lt;br&gt;}  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, the &lt;strong&gt;@au_id&lt;/strong&gt; parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the &lt;strong&gt;SqlParameter&lt;/strong&gt; class throws an exception.&lt;/p&gt;&lt;h2&gt;Review Your Application's Use of Parameterized Stored Procedures&lt;/h2&gt;&lt;p&gt;Because using stored procedures with parameters does not necessarily prevent SQL injection, you should review your application's use of this type of stored procedure. For example, the following parameterized stored procedure has several security vulnerabilities.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;CREATE PROCEDURE dbo.RunQuery@var ntextAS&lt;br&gt;        exec sp_executesql @varGO  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An application that uses a stored procedure similar to the one in the preceding code example has the following vulnerabilities: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;The stored procedure executes whatever statement is passed to it. Consider the &lt;strong&gt;@var&lt;/strong&gt; variable being set to: &lt;div&gt;&lt;pre&gt;DROP TABLE ORDERS;  &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, the ORDERS table will be dropped. &lt;/p&gt;&lt;/li&gt;&lt;li&gt;The stored procedure runs with &lt;strong&gt;dbo&lt;/strong&gt; privileges. &lt;/li&gt;&lt;li&gt;The stored procedure's name (&lt;strong&gt;RunQuery&lt;/strong&gt;) is a poor choice. If an attacker is able to probe the database, he or she will see the name of the stored procedure. With a name like &lt;strong&gt;RunQuery&lt;/strong&gt;, he can guess that the stored procedure is likely to run the supplied query. &lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Step 3. Use Parameters with Dynamic SQL&lt;/h1&gt;&lt;p&gt;If you cannot use stored procedures, you should still use parameters when constructing dynamic SQL statements. The following code shows how to use &lt;strong&gt;SqlParametersCollection&lt;/strong&gt; with dynamic SQL.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;using System.Data;&lt;br&gt;using System.Data.SqlClient;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;using (SqlConnection connection = new SqlConnection(connectionString))&lt;br&gt;{&lt;br&gt;&amp;nbsp; DataSet userDataset = new DataSet();&lt;br&gt;&amp;nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id", &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; connection);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);&lt;br&gt;&amp;nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text;&lt;br&gt;&amp;nbsp; myDataAdapter.Fill(userDataset);&lt;br&gt;}&lt;/pre&gt;&lt;h2&gt;Using Parameter Batching&lt;/h2&gt;&lt;p&gt;A common misconception is that if you concatenate several SQL statements to send a batch of statements to the server in a single round trip, you cannot use parameters. However, you can use this technique if you make sure that parameter names are not repeated. You can easily do this by making sure that you use unique parameter names during SQL text concatenation, as shown here.&lt;/p&gt;&lt;div&gt;&lt;pre&gt;using System.Data;&lt;br&gt;using System.Data.SqlClient;&lt;br&gt;. . .&lt;br&gt;using (SqlConnection connection = new SqlConnection(connectionString))&lt;br&gt;{&lt;br&gt;&amp;nbsp; SqlDataAdapter dataAdapter = new SqlDataAdapter(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "SELECT CustomerID INTO #Temp1 FROM Customers " +&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "WHERE CustomerID &amp;gt; @custIDParm; SELECT CompanyName FROM Customers " +&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "WHERE Country = @countryParm and CustomerID IN " +&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "(SELECT CustomerID FROM #Temp1);",&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; connection);&lt;br&gt;&amp;nbsp; SqlParameter custIDParm = dataAdapter.SelectCommand.Parameters.Add(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "@custIDParm", SqlDbType.NChar, 5);&lt;br&gt;&amp;nbsp; custIDParm.Value = customerID.Text;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp; SqlParameter countryParm = dataAdapter.SelectCommand.Parameters.Add(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; "@countryParm", SqlDbType.NVarChar, 15);&lt;br&gt;&amp;nbsp; countryParm.Value = country.Text;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp; connection.Open();&lt;br&gt;&amp;nbsp; DataSet dataSet = new DataSet();&lt;br&gt;&amp;nbsp; dataAdapter.Fill(dataSet);&lt;br&gt;}&lt;br&gt;. . .  &lt;/pre&gt;&lt;/div&gt;&lt;h1&gt;Additional Considerations&lt;/h1&gt;&lt;p&gt;Other things to consider when you develop countermeasures to prevent SQL injection include: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Use escape routines to handle special input characters. &lt;/li&gt;&lt;li&gt;Use a least-privileged database account. &lt;/li&gt;&lt;li&gt;Avoid disclosing error information. &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Use Escape Routines to Handle Special Input Characters&lt;/h2&gt;&lt;p&gt;In situations where parameterized SQL cannot be used and you are forced to use dynamic SQL instead, you need to safeguard against input characters that have special meaning to SQL Server (such as the single quote character). If not handled, special characters such as the single quote character in the input can be utilized to cause SQL injection. &lt;/p&gt;&lt;blockquote&gt;&lt;strong&gt;Note&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Special input characters pose a threat only with dynamic SQL and not when using parameterized SQL. &lt;/blockquote&gt;&lt;p&gt;Escape routines add an escape character to characters that have special meaning to SQL Server, thereby making them harmless. This is illustrated in the following code fragment:&lt;/p&gt;&lt;div&gt;&lt;pre&gt;private string SafeSqlLiteral(string inputSQL){  return inputSQL.Replace("'", "''");&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;}&lt;/p&gt;&lt;h2&gt;Use a Least-Privileged Database Account&lt;/h2&gt;&lt;p&gt;Your application should connect to the database by using a least-privileged account. If you use Windows authentication to connect, the Windows account should be least-privileged from an operating system perspective and should have limited privileges and limited ability to access Windows resources. Additionally, whether or not you use Windows authentication or SQL authentication, the corresponding SQL Server login should be restricted by permissions in the database.&lt;/p&gt;&lt;p&gt;Consider the example of an ASP.NET application running on Microsoft Windows Server 2003 that accesses a database on a different server in the same domain. By default, the ASP.NET application runs in an application pool that runs under the Network Service account. This account is a least privileged account.&lt;/p&gt;&lt;h3&gt;To access SQL Server with the Network Service account &lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Create a SQL Server login for the Web server's Network Service account. The Network Service account has network credentials that are presented at the database server as the identity &lt;em&gt;DOMAIN&lt;/em&gt;\&lt;em&gt;WEBSERVERNAME&lt;/em&gt;$. For example, if your domain is called XYZ and the Web server is called 123, you create a database login for XYZ\123$. &lt;/li&gt;&lt;li&gt;Grant the new login access to the required database by creating a database user and adding the user to a database role. &lt;/li&gt;&lt;li&gt;Establish permissions to let this database role call the required stored procedures or access the required tables in the database. Only grant access to stored procedures the application needs to use, and only grant sufficient access to tables based on the application's minimum requirements. &lt;p&gt;For example, if the ASP.NET application only performs database lookups and does not update any data, you only need to grant read access to the tables. This limits the damage that an attacker can cause if the attacker succeeds in a SQL injection attack. &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Avoid Disclosing Error Information&lt;/h2&gt;&lt;p&gt;Use structured exception handling to catch errors and prevent them from propagating back to the client. Log detailed error information locally, but return limited error details to the client. &lt;/p&gt;&lt;p&gt;If errors occur while the user is connecting to the database, be sure that you provide only limited information about the nature of the error to the user. If you disclose information related to data access and database errors, you could provide a malicious user with useful information that he or she can use to compromise your database security. Attackers use the information in detailed error messages to help deconstruct a SQL query that they are trying to inject with malicious code. A detailed error message may reveal valuable information such as the connection string, SQL server name, or table and database naming conventions.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Adapted from Microsoft patterns &amp;amp; practices guidance.&lt;/p&gt;</content>
</guidanceItem>