<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="9529c82f-dbc3-4c73-b1d3-6e47448fa6bc" Author="" Category="Input and Data Validation" Priority="1" Rule_Type="How To" Status="" Technology=" Any" title="How to Test for Cross-Site Scripting (XSS) Bugs" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;br&gt;&lt;br&gt;&lt;h1&gt;Applies to&lt;/h1&gt;&lt;p&gt;XSS bugs affect applications that manipulate HTML input and output.&amp;nbsp; In particular web applications developed in ASP, ASP .NET, PHP, PERL, Java, and Visual Basic.&lt;/p&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;Cross site scripting (or XSS) is a well known HTML-related security vulnerability that commonly affects Internet clients through XSS vulnerable servers.&amp;nbsp; A XSS bug in a web server allows an attacker to send malicious payload to a victim browser such as IE, Firefox, or Netscape through the vulnerable server.&amp;nbsp; &amp;nbsp;Payloads may also execute in other HTTP clients not necessarily focused at browsing the web as long as they render HTML and execute any execute scripts. &lt;/p&gt;&lt;p&gt;Below is a summary of steps needed for testing for XSS bugs&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Step 1&lt;/strong&gt;:&amp;nbsp; Understand XSS attack scenarios&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Step 2&lt;/strong&gt;:&amp;nbsp; List high risk components&lt;strong&gt; &lt;/strong&gt;and&lt;strong&gt; &lt;/strong&gt;entry points&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Step 3&lt;/strong&gt;:&amp;nbsp; Start testing and exploring&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Step 4&lt;/strong&gt;:&amp;nbsp; Tune test case data&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Step1:&amp;nbsp; Understand XSS Attack Scenarios&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;There are two types of XSS: reflective and persistent.&amp;nbsp; A reflective XSS bug occurs when the web server takes input from a visitor and automatically sends him back the input without checking if the data inputted contains a script.&amp;nbsp; Thus, the input data is &lt;em&gt;reflected&lt;/em&gt; to the visitor and executes at the visitor's browser.&amp;nbsp;&lt;/p&gt;&lt;p&gt;A persistent XSS bug is when a script embedded in malicious data is stored in a persistent store such as database, a file, or other storing mechanism.&amp;nbsp; The malicious data containing a script &lt;em&gt;persists&lt;/em&gt; in the server.&amp;nbsp;&amp;nbsp; If the server application takes this stored content and sends it to the client without validating its contents, the script will be executed in the browser.&amp;nbsp;&lt;/p&gt;&lt;p&gt;It is important to understand both XSS attack scenarios to know what to look at when testing.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Reflective XSS through web search form scenario&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A web site has a search page named search.php that contains the following form:&lt;/p&gt;&lt;p&gt;&lt;img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image001.png"&gt;&lt;/p&gt;&lt;p&gt;&amp;lt;form&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;input name="searchInput" type="text" size="50"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;input name="searchButton" type="button" size="20" value="search"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/form&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;It collects input using the searchInput variable and shows the results in the same page:&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;p&amp;gt; Search results for &amp;lt;?php echo $_GET['searchInput']?&amp;gt; are:&lt;/p&gt;&lt;p&gt;&amp;nbsp;The user can type test and will see:&lt;/p&gt;&lt;p&gt;&lt;img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image003.png"&gt;&lt;/p&gt;&lt;p&gt;An attacker can exploit the searchInput variable using the SCRIPT tag and type:&lt;/p&gt;&lt;p&gt;&lt;img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image005.png"&gt;&lt;/p&gt;&lt;p&gt;The server will send the user a page containing a SCRIPT tag and the user browser will execute its contents and display a message box with the word XSS.&amp;nbsp; An attacker can send an email to a victim and tell her to click the following URL:&lt;/p&gt;&lt;p&gt;http://teammentorexample.com/search/search.php?searchInput=&amp;lt;SCRIPT&amp;gt;payload&amp;lt;/SCRIPT&amp;gt;&lt;/p&gt;&lt;p&gt;When following the link, the malicious payload executes in the victim browser's context and can be used for stealing session or cookie information.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Persistent XSS through a SQL database server&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A web application creates a profile web page by querying a database table and getting profile information from it. The problem is that the database doesn't check for a possible script being stored in the database.&amp;nbsp; To display the user's favorite quote it uses the following PHP code:&lt;/p&gt;&lt;p&gt;echo 'favorite quote:&amp;nbsp; &amp;lt;br&amp;gt;';&lt;/p&gt;&lt;p&gt;$connection = odbc_connect("sqldb", "admin", "root");&lt;/p&gt;&lt;p&gt;$query = "SELECT quote FROM ProfileTable WHERE UserName = " . &amp;nbsp;$_GET['user']"; &lt;/p&gt;&lt;p&gt;$result = odbc_exec($connection, $query);&lt;/p&gt;&lt;p&gt;odbc_fetch_row($result);&lt;/p&gt;&lt;p&gt;$quote = odbc_result($result, 1); &lt;/p&gt;&lt;p&gt;print($quote);&lt;/p&gt;&lt;p&gt;An attacker with a profile name of 'JohnB' connected to the database before and set this information in his profile as his favorite quote:&lt;/p&gt;&lt;p&gt;&amp;lt;SCRIPT&amp;gt;alert('XSS') &amp;lt;/SCRIPT&amp;gt;&lt;/p&gt;&lt;p&gt;Now, every time that anyone visits the their profile by following a link like this one will see the alert box:&lt;/p&gt;&lt;p&gt;&amp;nbsp;http://teammentorexample.com/showProfile.php?user=JohnB&lt;/p&gt;&lt;p&gt;The attacker can modify the alert box with a more dangerous payload such as stealing session or cookie information.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Step 2: List High Risk Components and Entry Points&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Identify high risk components&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The next step in testing for XSS bugs is to do an extensive and careful revision of components that take input data from Internet clients and use send it back to the client.&amp;nbsp; In case of large web services, documentation such as design or architectural, if available, become real handy at this point. &amp;nbsp;&amp;nbsp;Testers need to think about what components reflect data to a web client (for reflective XSS) and store data which is later send to a web client (for persistent XSS).&amp;nbsp; Common components that do this include:&amp;nbsp;&lt;/p&gt;&lt;p&gt;Search web pages&lt;/p&gt;&lt;p&gt;Profile-related web pages&lt;/p&gt;&lt;p&gt;Web forums&lt;/p&gt;&lt;p&gt;Blogs&lt;/p&gt;&lt;p&gt;RSS feeds&lt;/p&gt;&lt;p&gt;HTML-based help browsers for thick clients&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Look for code that writes HTML responses&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;There are many different scripting functions that append HTML to the server response.&amp;nbsp; Finding the server-side code that writes data out is the first step evaluating and finding potential XSS issues.&amp;nbsp; Here are some examples of functions that do that:&lt;/p&gt;&lt;p&gt;Response.Write&amp;nbsp;&amp;nbsp;&amp;nbsp; (ASP)&lt;/p&gt;&lt;p&gt;&amp;lt;%= %&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (ASP)&lt;/p&gt;&lt;p&gt;echo&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (PHP)&lt;/p&gt;&lt;p&gt;print&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (PHP)&lt;/p&gt;&lt;p&gt;Functions to write data to a response vary depending on the language and platform you're testing.&amp;nbsp; Be certain that you understand all the relevant functions in the language you're using.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Check for non-validated and unencoded data in responses&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Next, check what is being output by the mechanisms above.&amp;nbsp; For example, an application might do this:&lt;/p&gt;&lt;p&gt;Response.Write(Request.QueryString(search))&lt;/p&gt;&lt;p&gt;To write the contents of the search value in the URL.&amp;nbsp; If the variable is set to a script it will execute as soon as the client renders the page written.&lt;/p&gt;&lt;p&gt;The following PHP code doesn't look so harmful at first.&amp;nbsp; &lt;/p&gt;&lt;p&gt;print($quote);&lt;/p&gt;&lt;p&gt;However, if the quote variable is a string that directly comes from a database like in the persistent scenario above then it suffers of XSS.&lt;/p&gt;&lt;p&gt;Look carefully at cases where the output data comes from a back-end though a database or a web method.&amp;nbsp; It might be that a web method returns non-validated data:&lt;/p&gt;&lt;p&gt;Response.Write(ExternalApplication.GetRSSFeedMethod())&lt;/p&gt;&lt;p&gt;Even if the data written out by an application comes directly from the user and has not been specifically validated for format, if it is appropriately encoded, it can still be safe.&amp;nbsp; That said, the encoding must take the form of a whitelist of known-safe characters (generally only the alphanumerics), not a blacklist as is commonly attempted.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Match high risk components with entry points&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Non-validated data comes from all of the application's entry points, not just the web.&amp;nbsp; Be certain to cover all the possible sources of malicious data which might get passed to a client.&amp;nbsp; Common data sources include:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Web forms&lt;/li&gt;&lt;li&gt;URL contents&lt;/li&gt;&lt;li&gt;Cookie contents&lt;/li&gt;&lt;li&gt;Flash parameters&lt;/li&gt;&lt;li&gt;SQL database query contents&lt;/li&gt;&lt;li&gt;Web service data&lt;/li&gt;&lt;li&gt;Graphical User Interface&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;List the high risk variables in the application and their data sources to make sure that they are covered during review and testing&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image007.png"&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Step 3:&amp;nbsp; Start Test and Exploring&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;During this step testing is focused at submitting basic XSS fuzz strings and observing how the application reacts, and then trying to display a simple alert box that proves the existence of an XSS bug.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Start with a simple fuzz string&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Success in finding XSS bugs depends on whether the tester is able to store or reflect an HTML script in or through the server.&amp;nbsp; In almost all cases scripts are included in between SCRIPT tags (other tags also worked as explained later).&amp;nbsp; During this step, it is recommended to start exploring how the server application's high risk components react to tag related input.&amp;nbsp; A good idea is to start testing a simple fuzz string like this one:&lt;/p&gt;&lt;p&gt;'&amp;gt;;!--"&amp;gt;&amp;lt;XYZ&amp;gt;&amp;lt;=&amp;amp;{()}&lt;/p&gt;&lt;p&gt;Then look for the string XYZ in server's response to see how the server processed the special script related characters.&amp;nbsp; It might turn out that the server uses the string inside of a tag:&lt;/p&gt;&lt;p&gt;&amp;lt;&lt;strong&gt;input&lt;/strong&gt; type="text" name="keyword" id="keyword" maxlength="255" value=&lt;a name="line163"&gt;&lt;/a&gt;"'&amp;gt;;!--"&amp;gt;&amp;lt;&lt;strong&gt;XYZ&lt;/strong&gt;&amp;gt;&amp;lt;=&amp;amp;{()}" style="height:10px; color:#000;" /&amp;gt;&lt;/p&gt;&lt;p&gt;Continue by modifying the initial string to try displaying an alert.&amp;nbsp; The double quotes of the original fuzz string closed the &lt;em&gt;value&lt;/em&gt; property so whatever came before doesn't matter.&amp;nbsp; Also, after the closing parenthesis next to the letter Z the string can be anything.&amp;nbsp; Taking the string can be simplified to this:&lt;/p&gt;&lt;p&gt;"&amp;gt;&amp;lt;XYZ&amp;gt;&lt;/p&gt;&lt;p&gt;The server might reply with:&lt;/p&gt;&lt;p&gt;&amp;lt;&lt;strong&gt;input&lt;/strong&gt; type="text" name="keyword" id="keyword" maxlength="255" value=&lt;a name="line1631"&gt;&lt;/a&gt;""&amp;gt;&amp;lt;&lt;strong&gt;XYZ&lt;/strong&gt;&amp;gt;" style="height:10px; color:#000;" /&amp;gt;&lt;/p&gt;&lt;p&gt;To learn more,&amp;nbsp;see the XSS Cheat Sheet at&amp;nbsp;Ha.ckers.com (&lt;a href="http://ha.ckers.org/xss.html"&gt;http://ha.ckers.org/xss.html&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Try to display an alert box&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The following goal is to execute a script and the easiest script to test is the one shown in the first scenario that displays an alert box.&amp;nbsp; Note that now the tester knows that the malicious sting needs to start with the "&amp;gt; character, due to where in the HTML document it will appear:&lt;/p&gt;&lt;p&gt;"&amp;gt;&amp;lt;script&amp;gt;alert('Works')&amp;lt;/script&amp;gt;&lt;/p&gt;&lt;p&gt;If the server doesn't filter the SCRIPT tags then an alert box will appear.&amp;nbsp; The code sent back to the tester will look like this.&lt;/p&gt;&lt;p&gt;&amp;lt;&lt;strong&gt;input&lt;/strong&gt; type="text" name="keyword" id="keyword" maxlength="255" value=&lt;a name="line16311"&gt;&lt;/a&gt;""&amp;gt;&lt;span style="text-decoration:underline"&gt;&amp;lt;script&amp;gt;alert('Works')&amp;lt;/script&amp;gt;&lt;/span&gt;" style="height:10px; color:#000;" /&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Cover different tags&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sometimes severs filter out the string &amp;lt;script&amp;gt; from their output.&amp;nbsp; If the server doesn't allow script tags, try the img tag and put your code in the src property:&lt;/p&gt;&lt;p&gt;"&amp;gt;&amp;lt;img src="javascript:alert('Works');"&amp;lt;/img&amp;gt;&lt;/p&gt;&lt;p&gt;In fact, there are many other tags known to be dangerous in some cases, such as &amp;lt;iframe&amp;gt;, &amp;lt;body&amp;gt;, &amp;lt;embed&amp;gt;, &amp;lt;meta&amp;gt;, &amp;lt;html&amp;gt;, &amp;lt;frame&amp;gt;, &amp;lt;frameset&amp;gt;, &amp;lt;input&amp;gt;, &amp;lt;layer&amp;gt;, &amp;lt;object&amp;gt;, and &amp;lt;style&amp;gt;. &lt;/p&gt;&lt;p&gt;A good choice is to try the following that doesn't require script tags or the JavaScript command:&lt;/p&gt;&lt;p&gt;"&amp;gt;&amp;lt;body onload=alert('Works')&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Step 4:&amp;nbsp; Tune Test Case Data&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;During this step testing is focused at covering all entry points and tuning test case data based on the format of the specific entry point.&amp;nbsp;&amp;nbsp; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Consider string format and encoding according to entry point&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The example in step 3 doesn't specify how the fuzz string was passed to the application (it can be assumed that it was through a web form for these purposes). &amp;nbsp;During this step, testers need to go through their list of components and entry points and modify test case data according to the entry point.&amp;nbsp; Make sure that all entry points are covered.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Web Forms&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Web forms are the easiest to test since they commonly allow only ASCII strings.&amp;nbsp; To test through this entry point, just go through the high risk component list looking for ones that have web forms.&amp;nbsp; Then use a web browser to submit test strings to the components via the forms, and possibly an attack proxy like Burp Suite to circumvent any client-side JavaScript used for data validation.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;URL Contents&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A web application is vulnerable to XSS through the value passed in the password variable:&amp;nbsp;&lt;/p&gt;&lt;p&gt;http://www.xvulnerablesite.com/login.asp?username=[value]&amp;amp;password=[value]&lt;/p&gt;&lt;p&gt;If testers want to test the following string in the password value:&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;script&amp;gt;alert('Works')&amp;lt;/script&amp;gt;&lt;/p&gt;&lt;p&gt;They will need to modify the above URL in this way:&lt;/p&gt;&lt;p&gt;http://www.xvulnerablesite.com/login.asp?username=any&amp;amp;password=&amp;lt;script&amp;gt;alert('Works')&amp;lt;/script&amp;gt;&lt;/p&gt;&lt;p&gt;When executing test cases through the URL it is important to try different encodings of the test string.&amp;nbsp;&amp;nbsp; For instance, one can execute the first attack string below and it causes no effect.&amp;nbsp; Then execute the second one and the alert box works.&amp;nbsp; In this case the web application didn't allow the symbol characters (except the round brackets) in ASCII but did in their hexadecimal encodings:&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;img src="javascript:alert('Works');"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;http://www.xvulnerablesite.com/login.asp?username=any&amp;amp;password=&amp;lt;img%20src%3d%22javascript:alert(%27Works%27)%22&amp;gt;&lt;/p&gt;&lt;p&gt;When testing through the URL and sometimes in other places, it is necessary to investigate what type of encodings the server is using and modify test cases according to them.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Cookie contents&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sometimes the application blindly displays the contents of a cookie in the web browser such as showed in the following PHP code:&lt;/p&gt;&lt;p&gt;&amp;lt;?php&amp;nbsp; echo $_COOKIE["testcookie"]; ?&amp;gt;&lt;/p&gt;&lt;p&gt;To test the risky component through this entry point we have to modify the cookie file in disk and try to inject a simple script:&lt;/p&gt;&lt;p&gt;&lt;img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image009.png"&gt;&lt;/p&gt;&lt;p&gt;Then restart the browser and navigate to the page containing the PHP code to see if an alert box appears.&amp;nbsp; Alternately, an attack proxy can be used to perform this modification on the fly, which is especially helpful in the case of complicated applications.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Flash Parameters&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Since Flash parameters are frequently passed in the URL, testing Flash parameters is similar to testing URL contents.&amp;nbsp; Here, it is necessary to go through each parameter in the URL and see how the application reacts.&amp;nbsp; Flash also frequently receives parameters using &lt;strong&gt;FlashVars&lt;/strong&gt;.&amp;nbsp; Consider the following code to load a Flash movie:&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"&lt;/p&gt;&lt;p&gt;&amp;nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""&lt;/p&gt;&lt;p&gt;&amp;nbsp;width="250" height="250" id="flaMovie1" align="center"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=movie value="flaMovie1.swf"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=&lt;strong&gt;FlashVars&lt;/strong&gt; value=&lt;strong&gt;"inputURL=usersinput"&lt;/strong&gt;&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=quality value=high&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=bgcolor value=#ffffff&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;embed src="flaMovie1.swf" &lt;strong&gt;FlashVars&lt;/strong&gt;=&lt;strong&gt;"inputURL=usersinput"&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" &lt;/p&gt;&lt;p&gt;&amp;nbsp; name="flaMovie1" align type="application/x-shockwave-flash" &lt;/p&gt;&lt;p&gt;&amp;nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/object&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;During this step, testers will need to change the entry parameters to Flash like this:&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"&lt;/p&gt;&lt;p&gt;&amp;nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""&lt;/p&gt;&lt;p&gt;&amp;nbsp;width="250" height="250" id="flaMovie1" align="CENTER"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=movie value="flaMovie1.swf"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=&lt;strong&gt;FlashVars&lt;/strong&gt; value=&lt;strong&gt;"inputURL=%3cscript%3ealart%28%b4XSS%b4%29%3c%2fscript%3e"&lt;/strong&gt;&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;param name=quality value=high&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;para name=bgcolor value=#ffffff&amp;gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;lt;embed src="flaMovie1.swf" &lt;strong&gt;FlashVars&lt;/strong&gt;=&lt;strong&gt;"inputURL=%3CSCRIPT%3Ealert%28%B4XSS%B4%29%3C%2FSCRIPT%3E"&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;&amp;nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" &lt;/p&gt;&lt;p&gt;&amp;nbsp; name="flaMovie1" align type="application/x-shockwave-flash" &lt;/p&gt;&lt;p&gt;&amp;nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/object&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Graphical User Interface&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Testing through the UI is similar to web form testing in that the tester enters test values&amp;nbsp; directly to the screen.&amp;nbsp; In the case of GUI testing the application used is not a web browser but any other application that interacts with high risk components, renders HTML,&amp;nbsp; and that allows user input or otherwise receives untrusted data.&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Look for additional entry points&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Each application has its own set of entry points.&amp;nbsp; This article lists the common ones for XSS attacks.&amp;nbsp; Nonetheless, testers must explore their application for additional ways of passing data that might make it into a XSS vulnerability.&amp;nbsp; It is recommended to use system monitoring tools such as the ones from www.sysinternals.com and dedicated attack tools such as Burp proxy that lets you intercept and add match-and-replace rules to change the contents of HTTP packets.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Keep tuning test cases &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sometimes the initial test string can land in a part of the source code where XSS is possible without using a script tag.&amp;nbsp; The tester may be able to pad it a little or maybe just write the JavaScript command.&amp;nbsp; Always check if the initial input lands inside or within an actual command or parameter.&lt;/p&gt;&lt;p&gt;Tags have different ways of modifying them for script injection.&amp;nbsp; To learn more about testing web applications for Cross-Site Scripting Vulnerabilities, see &lt;a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx"&gt;http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx&lt;/a&gt;&amp;nbsp;and&amp;nbsp; &lt;a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors"&gt;http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Consider the case of persistent XSS&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sometimes the tester won't see the results of test cases right away.&amp;nbsp; An XSS bug might exist that takes malicious input and only sends it back if the attacker does something else like visiting another page, for instance.&amp;nbsp; Such is often the case with a persistent XSS attack.&lt;/p&gt;&lt;p&gt;Consider the following case.&amp;nbsp; An application asks for a user's password hint.&amp;nbsp; When the server prompts the user for the hint, the attacker types one of the XSS test strings described before.&amp;nbsp; Then submits the registration but the server doesn't show the alert box.&amp;nbsp; Then the attacker has the victim browse the site's password page and ask for the hint.&amp;nbsp; When the site displays the hint the alert box appears.&amp;nbsp; &lt;/p&gt;&lt;p&gt;While testing persistent XSS, testers must think of all the places where the input might end up and check all of them.&amp;nbsp; They should talk to developers and use specifications to check all data stores where a persistent XSS bug can manifest.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Automating test cases&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;One can automate XSS testing by setting up a server that collects any successful XSS attacks.&amp;nbsp; For instance, can create an ASP page that has the following code, and name the page results.asp&lt;/p&gt;&lt;p&gt;&amp;lt;%&lt;br&gt;&amp;nbsp;&amp;nbsp; set fso = Server.CreateObject("Scripting.FileSystemObject")&lt;br&gt;&amp;nbsp;&amp;nbsp; set fw = fso.CreateTextFile("c:\inetpub\wwwroot\results.txt",True)&lt;br&gt;&amp;nbsp;&amp;nbsp; fw.WriteLine("test case:")&lt;br&gt;&amp;nbsp;&amp;nbsp; fw.WriteLine(Request.QueryString("testcase"))&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp; fw.Close &lt;br&gt;%&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Then generate test cases by modifying or creating new HTTP requests to the target server.&amp;nbsp; Instead of displaying alert the script invokes results.asp passing its corresponding test case number (using the src property of HTML tags).&amp;nbsp; For example the tester wants to cover XSS through the img tag in the password field of the login page.&amp;nbsp; He labels this test case number 17.&amp;nbsp; Then passes the following string using automation:&lt;/p&gt;&lt;p&gt;http://www.xvulnerablesite.com/login.asp?username=any&amp;amp;password=&amp;lt;img src="http://xyoursite.com/results.asp?testcase=17"&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;If this test case fails then the value 17 appears in the results.txt file and the tester knows that a XSS bug was found and what caused it.&amp;nbsp; Testers can code hundreds of test cases like this and a test generator like an HTTP client to guide the automation.&amp;nbsp;&lt;/p&gt;&lt;p&gt;In addition, look at the different fuzzers available for free at &lt;a href="http://en.wikipedia.org/wiki/Fuzz_testing"&gt;http://en.wikipedia.org/wiki/Fuzz_testing&lt;/a&gt;.&amp;nbsp; Many of these have the capability of executing XSS test cases and help in uncovering vulnerabilities.&lt;/p&gt;&lt;h1&gt;Conclusions&lt;/h1&gt;&lt;p&gt;Testing for XSS bugs is not complicated but you need to be thorough.&amp;nbsp; It is important that you go through all the places where your web server renders HTML output.&amp;nbsp; There are many strings to try, many tags to look at, different methods to feed the test data, and even room for automation.&amp;nbsp; However, the most important thing to keep in mind is to follow your test data.&amp;nbsp; Don't just look for the alert box, but look at the code that comes back to you.&amp;nbsp; Successful XSS testing is all about knowing how to tune you test case data.&lt;/p&gt;&lt;h1&gt;Additional Resources&amp;nbsp;&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;XSS (Cross Site Scripting) Cheat Sheet.&amp;nbsp; Ha.ckers.com (&lt;a href="http://ha.ckers.org/xss.html"&gt;http://ha.ckers.org/xss.html&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;Testing Your Web Applications for Cross-Site Scripting Vulnerabilities, Chris Weber. &lt;a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx"&gt;http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx&lt;/a&gt;&amp;nbsp;&lt;/li&gt;&lt;li&gt;OWASP Testing Guide Appendix C: Fuzz Vectors. &lt;a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors"&gt;http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;Fuzz Testing.&amp;nbsp; Wikipedia. &lt;a href="http://en.wikipedia.org/wiki/Fuzz_testing"&gt;http://en.wikipedia.org/wiki/Fuzz_testing&lt;/a&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;div&gt;&amp;nbsp;&lt;a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E"&gt;Attack: Cross Site Scripting Attack&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</content>
</guidanceItem>