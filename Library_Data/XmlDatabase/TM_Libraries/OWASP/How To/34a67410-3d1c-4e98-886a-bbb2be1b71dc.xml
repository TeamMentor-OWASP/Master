<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="34a67410-3d1c-4e98-886a-bbb2be1b71dc" Author="" Category="Information Disclosure" Priority="" Rule_Type="How To" Status="" Technology=" Any" title="How to Test for Memory Sniffing Bugs" Topic="Security" phase="Test" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;All software applications &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;Applications must store sensitive data such as passwords or cryptographic values in system memory in order to properly operate. However, secrets may be stored in memory that is accessible to an attacker or swapped out of memory and into swaps files. During this attack, the attacker sniffs the different types of memory available, including random access memory (RAM), virtual memory, dump files, and swap files in an attempt to recover sensitive information such as passwords or cryptographic keys.&lt;/p&gt;&lt;p&gt;It is recommended that you follow these steps in order to test for this bug:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1: Understand attack scenarios &lt;/li&gt;&lt;li&gt;Step 2: Analyze causes and countermeasures &lt;/li&gt;&lt;li&gt;Step 3: Start testing and exploring &lt;/li&gt;&lt;li&gt;Step 4: Execute additional testing&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;h1&gt;Step 1: Understand attack scenarios&lt;/h1&gt;&lt;p&gt;First, it is necessary to properly understand the types of temporary memory related to this vulnerability:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RAM - physical memory that stores data used by running processes. &lt;/li&gt;&lt;li&gt;Virtual memory - logical address space given by the system to each running process. It gets copied into random access memory and swapped out to swap files by the operating system. &lt;/li&gt;&lt;li&gt;Swap files - RAM’s auxiliary storage. The operating system performs paging to swap the contents of RAM in and out of swap files. &lt;/li&gt;&lt;li&gt;Memory dumps - Memory dumps are snapshots of a process’s virtual memory; they are created by the system when the process crashes.&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Note that permanent storage of user files, databases, and the Windows registry is outside of the scope of this vulnerability. Permanent memory can be protected using permissions and relate to information disclosure attacks.&lt;/p&gt;&lt;p&gt;Memory sniffing bugs commonly relate to local attacks requiring access to the target computer. Once the attacker is logged in, he uses a tool to recover sensitive data such as passwords or keys from temporary memory.&lt;/p&gt;&lt;p&gt;In detail:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Attacker logs in to target machine.* &lt;/li&gt;&lt;li&gt;Attacker uses a script or tool to search memory for sensitive data. The attack ends if sensitive data is recovered is an unhashed/unencrypted form. &lt;/li&gt;&lt;li&gt;If sensitive data is hashed or encrypted, the attacker uses a cryptographic attack to recover sensitive data in plain-text.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;* Variations of this attack focus on capturing sensitive information without access to the target machine. For instance, forensic research shows that the contents of a computer’s RAM can be retrieved through a FireWire cable [i]. Furthermore, recent discoveries indicate that sensitive information from DRAM chips can be restored by removing them after the computer has been turned off.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 2: Analyze Causes and Countermeasures&lt;/h1&gt;&lt;p&gt;The next step in testing for memory sniffing is to understand what causes this vulnerability and how to countermeasure it.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Clearing data structures containing sensitive information &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;A classic approach to protect against memory sniffing attacks is to clear data structures, such as arrays, used to temporarily store sensitive information. For instance, the code below is insecure:&lt;/p&gt;&lt;pre&gt;&lt;/pre&gt;&lt;pre&gt;void GetData(char *MFAddr) { &lt;br&gt;  char pwd[64];&lt;br&gt;&amp;nbsp;  if (GetPasswordFromUser(pwd, sizeof(pwd))) {&lt;br&gt;&amp;nbsp;&amp;nbsp;    if (ConnectToMainframe(MFAddr, pwd)) {&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;    &amp;nbsp;// Interaction with mainframe&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;    &amp;nbsp;}&lt;br&gt;&amp;nbsp;  }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The function &lt;em&gt;GetPasswordFromUser&lt;/em&gt; copies a password provided by the user to the &lt;em&gt;pwd&lt;/em&gt; character array. The application then returns from the function without cleaning the password from memory. To mitigate this attack, developers are encouraged to set the memory contents to zero after the process is done with the structure used to store it:&amp;nbsp;&lt;/p&gt;&lt;pre&gt;void GetData(char *MFAddr) { &lt;br&gt;  char pwd[64];&lt;br&gt;&amp;nbsp;  if (GetPasswordFromUser(pwd, sizeof(pwd))) {&lt;br&gt;    if (ConnectToMainframe(MFAddr, pwd)) {&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;    &amp;nbsp;// Interaction with mainframe&lt;br&gt;&amp;nbsp;&lt;br&gt;    &amp;nbsp;&amp;nbsp;}&lt;br&gt;&amp;nbsp;  }&lt;br&gt;&amp;nbsp;  &lt;strong&gt;memset(pwd, 0, sizeof(pwd));&lt;br&gt;&lt;/strong&gt;}&lt;br&gt;&lt;/pre&gt;&lt;p&gt;However, it is extremely important to know that &lt;em&gt;memset&lt;/em&gt; might not work as intended if compiler optimizations are on. Make sure to turn off compiler optimizations if protecting your code using &lt;em&gt;memset&lt;/em&gt; as shown above. For more information, refer to &lt;em&gt;OWASP’s Insecure Compiler Optimization &lt;/em&gt;[ii].&lt;/p&gt;&lt;p&gt;Another way of clearing out memory is by traversing the array and setting each element to zero:&lt;/p&gt;&lt;pre&gt;&lt;br&gt;void erase_string(char *s) {&lt;/pre&gt;&lt;pre&gt;  while(*s) { *s++ = 0; }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;This technique is recommended, because it doesn’t depend on compiler optimizations or knowledge of the array’s size. To properly secure your application, it is suggested that you add similar zeroing-out techniques after returning from function calls that deal with sensitive data and also in every destructor of classes that deal with secrets such as passwords and cryptographic elements.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Locking sensitive memory &lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Zeroing out sensitive memory is an effective technique to keep sensitive data in virtual memory (and consequently in RAM and swap files) as briefly as possible. However, this data might still get swapped by the operating system’s paging system into swap files before the application has a chance to clean it, increasing the risk of harm from a memory sniffing attack. &lt;/p&gt;&lt;p&gt;It is possible to mitigate this condition by locking virtual address pages from being swapped. This can be achieved in the UNIX platforms by using &lt;em&gt;mlock&lt;/em&gt; as below [iii]:&lt;/p&gt;&lt;pre&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/pre&gt;&lt;pre&gt;&lt;br&gt;void *locking_alloc(size_t numbytes) {&lt;/pre&gt;&lt;pre&gt;  static short have_warned = 0;&lt;/pre&gt;&lt;pre&gt;&amp;nbsp;  void *mem = malloc(numbytes);&lt;/pre&gt;&lt;pre&gt;&lt;br&gt;  if(mlock(mem, numbytes) &amp;amp;&amp;amp; !have_warned) {&lt;br&gt;&amp;nbsp;&lt;br&gt;    /* We probably do not have permission.&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;       * Sometimes, it might not be possible to lock enough memory.&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;       */&lt;/pre&gt;&lt;pre&gt;    fprintf(stderr, "Warning: Using insecure memory!\n");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;    have_warned = 1;&lt;br&gt;&amp;nbsp;&lt;br&gt;  } &lt;/pre&gt;&lt;pre&gt;  return mem;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In Windows, the Win32 API VirtualLock is used for the same purpose.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Disable the creation of dump files&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;An attacker might execute a memory sniffing attack by crashing an application and accessing the core dumps created by the system upon the crash. Any sensitive data loaded by the application into any data structure will appear in dump files for the attacker to leverage. To mitigate this condition, processes must disable the creation of dump files right from the start. This is achieved using the &lt;em&gt;setrlimit&lt;/em&gt; API both in UNIX and Windows platforms [iv]:&lt;/p&gt;&lt;pre&gt;char pwd[MAX_PWD_LEN];&lt;br&gt;if(setrlimit(RLIMIT_CORE, 0) != 0) {&lt;br&gt;  /* deal with error */&lt;br&gt;}&lt;br&gt;&amp;nbsp;&lt;br&gt;fgets(pwd, MAX_PWD_LEN, stdin);&lt;/pre&gt;&lt;h2&gt;&lt;em&gt;Additional countermeasures&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Additional defenses against memory sniffing attacks include deleting the page file on reboot or shutdown (this can be done by setting a registry value in Windows), and using forensic tools to scrub all different types of system memory. In addition, research is moving towards encrypting the contents of RAM and swap files and storing the encryption key in hardware.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 3: Start Testing and Exploring&lt;/h1&gt;&lt;p&gt;Now that you understand the basic theory behind memory sniffing attacks, it is necessary to execute practical test cases to check if your application is vulnerable. If you have implemented countermeasures, it is important to execute these tests before and after adding the countermeasures to test their effectiveness.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for sensitive data in RAM&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;In Windows platforms, follow these steps to create a record of physical memory in a text file:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Log into a Windows host running the application under test. &lt;/li&gt;&lt;li&gt;Download and install ManTech’s Memory DD (&lt;a href="https://sourceforge.net/projects/mdd/)"&gt;https://sourceforge.net/projects/mdd/)&lt;/a&gt;. &lt;/li&gt;&lt;li&gt;Open command prompt with administrative privileges. &lt;/li&gt;&lt;li&gt;Run mdd as follows: &lt;strong&gt;mdd_1.3.exe -o c:\ram.txt -v&lt;/strong&gt; &lt;/li&gt;&lt;li&gt;Once mdd finishes executing, read output file ram.txt for sensitive information.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: ram.txt must not show any sensitive data.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for sensitive data in virtual memory&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;The best way to search your application’s virtual memory for secrets is to use a debugger to create a dump of the virtual memory space at any given time:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Log into a Windows host running the application under test. &lt;/li&gt;&lt;li&gt;Download and run user-mode Windows debugging &lt;em&gt;windbg.&lt;/em&gt; &lt;/li&gt;&lt;li&gt;Attach windbg to the application under test. &lt;/li&gt;&lt;li&gt;Break into the debugger and specify the option to create a full dump for the application’s virtual memory: &lt;strong&gt;.dump /f c:\dump.txt&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: dump.txt must not show any sensitive data.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for sensitive data in swap files&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;In Windows, swap files are stored in the &lt;em&gt;pagefile:&lt;/em&gt; &lt;/p&gt;&lt;ol&gt;&lt;li&gt;Log into a Windows host running the application under test. &lt;/li&gt;&lt;li&gt;Find pagefile&lt;em&gt;. &lt;/em&gt;It is named &lt;em&gt;pagefile.sys&lt;/em&gt; and is usually on the root drive of the Windows partition (i.e. c:\pagefile.sys). &lt;/li&gt;&lt;li&gt;Open read-only copy of a file. &lt;/li&gt;&lt;li&gt;Search for sensitive information in pagefile.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: pagefile must not show sensitive information.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for sensitive data in dump files&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these steps test for sensitive information in dump files:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Log into a Windows host running the application under test. &lt;/li&gt;&lt;li&gt;Find the dump files (in Windows, this is indicated in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl). &lt;/li&gt;&lt;li&gt;Open a dump file and search for sensitive information. &lt;/li&gt;&lt;li&gt;Repeat for each of the dump files&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: dump files must not show sensitive information.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 4: Execute Additional Testing&lt;/h1&gt;&lt;p&gt;If the sensitive data cannot be easily recognized, you must do additional testing. During each of the tests above, the attacker needs to interpret the output. Running each of the tools creates an output file with a large quantity of data that is irrelevant to the test. A good way to find secrets is running a command such &lt;em&gt;strings&lt;/em&gt; on the output file [v] in order to display all character arrays in the file:&lt;/p&gt;&lt;pre&gt;&lt;br&gt;C:\Documents and Settings\All Users\Documents\DrWatson&amp;gt;strings user.dmp&lt;br&gt;12&lt;/pre&gt;&lt;pre&gt;…&lt;br&gt;kernel32.dll&lt;br&gt;RASAPI32&lt;br&gt;C:\WINNT\tracing&lt;br&gt;C:\Documents and Settings\Administrator\My Documents\PGP\pubring.pkr&lt;br&gt;C:\Documents and Settings\Administrator\My Documents\PGP\secring.skr&lt;br&gt;&amp;amp; !&lt;br&gt;IN PGP MESSAGE-----&lt;br&gt;Version: PGP 7.1&lt;br&gt;qANQR1DBwU4DSL6Q3OHRwOYQB/9pKnnhZGQRFwykWzBO1EWkzW336QOkUaHj0aVj&lt;br&gt;P1MgxDWQWi3kZpOfGnDg6kbQriWBiIgD/z8p5xGN+WcksytlLJv8OxvTGMepx7u8&lt;br&gt;h5aVRXZd8YPM+h5ROpbnNw+SiT/w9oCy/ChWeiCHV1swQSzwBHx2Ye+yxO70Moxc&lt;br&gt;...&lt;br&gt;frAG3nM7kOnChQp4jxhv2J0p7fL1vteI9EGbcimC9QCVBwC1U++mQIqbTyIw5gWK&lt;br&gt;Io11yl8P+wKjcHsLfi2hTE+NIRb+VORWhVoCDHgNKV1nSFNTK0LEnvz84OFyRc1z&lt;br&gt;-----END PGP MESSAGE-----&lt;br&gt;&lt;strong&gt;&amp;lt;pgppassphrase!&amp;gt;&lt;/strong&gt;&lt;br&gt;…&lt;br&gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;Hex editors and similar low-level file processing tools must be used to identify sensitive data. Additional techniques include performing dictionary or linear searches. For example, in Linux refer to &lt;em&gt;Cryptographic Key Recovery from Linux Memory Dumps &lt;/em&gt;[vi]&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Conclusions&lt;/h1&gt;&lt;p&gt;Memory sniffing attacks aim at recovering sensitive data in system memory, including virtual memory, RAM, and swap files.In order to properly test for this bug, it is necessary to understand the anatomy of the attack scenario as well as why it is caused and how to protect against it.Then, you must use a set of available tools to check for it in your application by making records of the different types of memory and searching them for sensitive data.&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;br&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;[i] &lt;strong&gt;Hit by a Bus: Physical Access Attacks with Firewire.&amp;nbsp; Adam Boileau.&amp;nbsp; &lt;/strong&gt;Security-Assesment.com.&amp;nbsp; &lt;a href="http://www.storm.net.nz/static/files/ab_firewire_rux2k6-final.pdf"&gt;http://www.storm.net.nz/static/files/ab_firewire_rux2k6-final.pdf&lt;/a&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;[ii] &lt;strong&gt;Insecure Compiler Optimization&lt;/strong&gt;. OWASP. &lt;a href="http://www.owasp.org/index.php/Insecure_Compiler_Optimization"&gt;http://www.owasp.org/index.php/Insecure_Compiler_Optimization&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[iii] &lt;strong&gt;Protecting sensitive data in memory.&amp;nbsp; &lt;/strong&gt;John Viega.&amp;nbsp; CGI Security.&amp;nbsp; &lt;a href="http://www.cgisecurity.com/lib/protecting-sensitive-data.html"&gt;http://www.cgisecurity.com/lib/protecting-sensitive-data.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[iv] &lt;strong&gt;VOID MSC14-A. Protect memory when working with sensitive data&lt;/strong&gt;. Alex Volkovitsky CERT.&amp;nbsp; &lt;a href="https://www.securecoding.cert.org/confluence/display/seccode/VOID+MSC14-A.+Protect+memory+when+working+with+sensitive+data"&gt;https://www.securecoding.cert.org/confluence/display/seccode/VOID+MSC14-A.+Protect+memory+when+working+with+sensitive+data&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[v] &lt;strong&gt;Practical Approaches to Recovering Encrypted Digital Evidence. &lt;/strong&gt;Eoghan Casey&lt;strong&gt;.&amp;nbsp; &lt;/strong&gt;&lt;a href="http://www.utica.edu/academic/institutes/ecii/publications/articles/A04AF2FB-BD97-C28C-7F9F4349043FD3A9.pdf"&gt;http://www.utica.edu/academic/institutes/ecii/publications/articles/A04AF2FB-BD97-C28C-7F9F4349043FD3A9.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[vi] &lt;strong&gt;Cryptographic Key Recovery from Linux Memory Dumps&lt;/strong&gt;. Torbjörn Pettersson.&amp;nbsp; &lt;a href="http://events.ccc.de/camp/2007/Fahrplan/attachments/1300-Cryptokey_forensics_A.pdf"&gt;http://events.ccc.de/camp/2007/Fahrplan/attachments/1300-Cryptokey_forensics_A.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content>
</guidanceItem>