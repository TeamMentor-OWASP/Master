<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="f9452ba5-cfe8-4d99-b52c-a00e1f927bbb" Author="" Category="Input and Data Validation" Priority="" Rule_Type="How To" Status="" Technology="ASP.NET 3.5" title="How to Test for Path Manipulation Bugs in ASP.NET" Topic="Security" phase="Test" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;In a path manipulation attack, an attacker submits certain input to alter an internal file path used by the application, forcing the application to use a malicious path. Attackers may exploit this bug to read sensitive files on the server such as configuration files or another user’s files, as well as to modify or delete server-side files. &lt;/p&gt;&lt;p&gt;Follow these steps to test for path manipulation bugs in ASP.NET:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1: Understand attack scenarios&lt;/li&gt;&lt;li&gt;Step 2: Analyze causes and countermeasures&lt;/li&gt;&lt;li&gt;Step 3: Start testing and exploring&lt;/li&gt;&lt;li&gt;Step 4: Execute additional testing&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 1: Understand Attack Scenarios&lt;/h1&gt;&lt;p&gt;The first step in testing for path manipulation bugs is to understand the anatomy of an attack scenario. &lt;/p&gt;&lt;p&gt;To exploit this vulnerability, the attacker manipulates a file path in an HTTP request. If the application is vulnerable, it uses the manipulated file path to perform a file system operation. The attack starts with the attacker discovering an HTTP request that invokes a server-side file system operation such as reading, modifying, deleting, emailing, or printing a file. This request comes either from a web page or from a client-side script (such as in AJAX applications) and contains a variable (URL parameter, web form input, etc) that the server uses to determine what file to handle. &amp;nbsp;To execute the attack, the attacker submits the request but modifies this variable in an attempt to manipulate a server-side file, exploiting an intended functionality of the application for malicious purposes. If the attack is successful, the value provided by the attacker causes the server to access a file in a different path. In most cases, the attacker will be able to tell if the attack is successful shortly after executing it.&lt;/p&gt;&lt;p&gt;In detail:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The attacker finds an HTTP request that invokes a file system operation at the server.&lt;/li&gt;&lt;li&gt;The attacker locates a variable in an HTTP request used to determine the path for a file system operation.&lt;/li&gt;&lt;li&gt;The attacker submits the request, but modifies the path determining variable and waits for a server response.&lt;/li&gt;&lt;li&gt;The attacker verifies if the attack is successful by observing the server’s response.&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;em&gt;&lt;br&gt;Attack Variants&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Attackers can employ path manipulation attacks to achieve different threats. For example, an attacker can manipulate a path to read server configuration and password files, or to read files belonging to another user, in order to execute an information disclosure attack on the application. &amp;nbsp;Similarly, an attacker can manipulate a path to force the ASP.NET application into deleting a file needed to properly service its users, generating a denial of service situation.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 2: Analyze Causes and Countermeasures&lt;/h1&gt;&lt;p&gt;Next, before executing practical test cases, it is necessary to understand why these bugs exist and how to avoid them.&lt;/p&gt;&lt;p&gt;Path manipulation bugs affect ASP.NET applications that use input provided by clients to build a file path. For instance, the code below gets an input value from the user in an URL parameter named &lt;em&gt;filename&lt;/em&gt;:&lt;/p&gt;&lt;pre&gt;string filename = "/public/user_files/" + &lt;br&gt;Server.UrlDecode(Request.QueryString["filename"]);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&lt;br&gt;StreamReader streamReader = new StreamReader(filename);&lt;br&gt;while (streamReader.Peek() &amp;gt;= 0)&lt;br&gt;{&lt;br&gt;  Response.Write(streamReader.ReadLine());&lt;br&gt;}&lt;br&gt;streamReader.Close();&lt;/pre&gt;&lt;br&gt;&lt;p&gt;If the user provides an expected file name such as &lt;em&gt;file.txt&lt;/em&gt;, the application returns an expected user file:&lt;/p&gt;&lt;pre&gt;http://example.com.pe/example.aspx?filename=&lt;strong&gt;file.txt&lt;/strong&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;However, during a path manipulation scenario, an attacker provides a malicious value for the variable, hoping that the application uses it to determine a different file path:&amp;nbsp;&lt;/p&gt;&lt;pre&gt;http://example.com.pe/example.aspx?filename=&lt;strong&gt;../../private/secret.txt&lt;/strong&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The above string causes the application to go up two directories, navigate to the &lt;em&gt;private&lt;/em&gt; folder, and display &lt;em&gt;secret.txt.&lt;/em&gt; The example above is a common scenario of information disclosure due to path manipulation. Notice that the attack is possible because the code shown trusts the filename provided by the client; it starts by directly copying the input to the internal variable used to determine the filename, without properly validating it.&lt;/p&gt;&lt;p&gt;To protect against this bug ASP.NET applications must properly validate user input. Specifically, they must check if the input is safe to use in determining a file path. Developers can use blacklists that contain a list of all disallowed filename constructs such as “../” (without the quotes) and check if the user input appears in a blacklist. The problem with blacklists is that any variant of an attack that is not accounted for will execute unnoticed; to be effective, blacklists must account for all 100% of all attack variants -- which is unreasonable. The recommended approach to defend against this bug is to use &lt;em&gt;whitelists. &lt;/em&gt;Whitelists specify only safe constructs, and disallow any user input that doesn’t match any of the specified safe constructs. By doing this, they only need to specify what is good and don’t have to account for 100% of all attack variants. &lt;/p&gt;&lt;p&gt;A common way of implementing a whitelist is by using a regular expression to specify what is safe and to disallow all input that doesn’t match the regular expression:&lt;/p&gt;&lt;pre&gt;Regex validFilename = new Regex("^[a-zA-Z]{4,8}\.txt$");&lt;br&gt;string input = Server.UrlDecode(Request.QueryString["filename"]);&lt;br&gt;&amp;nbsp;&lt;br&gt;if (!validFilename.IsMatch(input))&lt;br&gt;{&lt;br&gt;  Response.Write("invalid input");&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;  string filename = "/public/user_files/" +&lt;br&gt;  &amp;nbsp;&amp;nbsp; Server.UrlDecode(Request.QueryString["filename"]);&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;  StreamReader streamReader = new StreamReader(filename);&lt;br&gt;  while (streamReader.Peek() &amp;gt;= 0)&lt;br&gt;  {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     Response.Write(streamReader.ReadLine());&lt;br&gt;  }&lt;br&gt;  streamReader.Close();&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The input must consist of four to eight consecutive upper- or lower-case letters followed by the extension &lt;em&gt;“.txt”&lt;/em&gt;. Any input that doesn’t match this form results in the application giving an &lt;em&gt;invalid input&lt;/em&gt; error.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Step 3: Start Testing and Exploring&lt;/h1&gt;&lt;p&gt;Now that you’ve learned the common attack scenarios as well as the causes and countermeasures for path manipulation bugs, it is necessary to execute basic test cases to check if your application is vulnerable.&lt;/p&gt;&lt;p&gt;Success in testing for path manipulation bugs depends on your ability to determine the variables the application uses to build a file path. Applications commonly use URL and web form variables, so it is necessary to understand how to test through these two input points. &lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for path manipulation in URL variables&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these steps to test for path manipulation in an URL variable:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Use an Internet browser to perform a file system operation. Note the URL used, such as &lt;em&gt;http://example.com.pe/example.asp?&lt;strong&gt;page=index.html&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;Locate the URL variable used to by the application to determine the file name (in this case it is &lt;em&gt;page&lt;/em&gt;).&lt;/li&gt;&lt;li&gt;Replace the value of the variable found in step 2 with an attack string (see Table 1). For instance: &lt;em&gt;http://example.com.pe/example.asp?page&lt;strong&gt;=&lt;/strong&gt;../../../boot.ini&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;Submit request to application and wait for response.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in step 3 to determine the response and the attacker-specified file is used in the response.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test for path manipulation in web form variables&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Follow these steps to test for path manipulation through web forms:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Navigate to a page containing a web form that prompts for a file name.&lt;/li&gt;&lt;li&gt;Locate the variable (input field) used by the application to determine the file name.&lt;/li&gt;&lt;li&gt;Enter an attack string in the field that indicates the filename (see Table 1). Here, it is important to disable any client-side checks that may deny entering an attack string due to illegal characters. For more information, read &lt;em&gt;How to - Test for Client-Side Validation Bypass Bugs&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;Submit the request to the application and wait for response.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Expected results are the same as the previous test case.&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Attack strings&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;The following attack strings contain path manipulation characters (dots, slashes, and backslashes) and common UNIX- and Windows-related file paths in different encodings. Depending on the relative location of the web application on the server, the number of “../” or “..\” clauses may need to be increased or decreased in order to realize an attack:&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;../etc/passwd&lt;br&gt;..\boot.ini&lt;br&gt;../boot.ini&lt;br&gt;folder_name/file_name&lt;br&gt;..\..\folder_name\file_name&lt;br&gt;../../folder_name/file_name&lt;br&gt;C:\boot.ini&lt;br&gt;%2e%2e\%2e%2e\&lt;br&gt;..%2f..%2f&lt;br&gt;%2e%2e%2f%2e%2e%2ffolder_name%2ffile_name&lt;br&gt;..%2f..%2ffolder_name%2ffile_name&lt;br&gt;..%c0%af..%c0%affolder_name..%c0%affile_name &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;&lt;p&gt;&lt;strong&gt;Table 1 - Path Manipulation Attack Strings&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Look for error messages that indicate file operations&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;While executing the basic test cases mentioned above, it is important to look for different type of error messages. For instance, “invalid input” or “incorrect format” error messages indicate that an application is safe, while “file not found” or HTTP 404 errors indicate that the application may be using the attack string to find a file in a different path and may be vulnerable to this bug.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;h1&gt;Step 4: Execute Additional Testing&lt;/h1&gt;&lt;p&gt;Finally, it is important to execute additional testing for double encoding scenarios, as well as to cover all of the application’s input points.&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Cover double encoding scenarios&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Since this attack requires passing malicious input to a web application, it is necessary to add double encoding test cases for proper coverage. Double encoding consists of re-encoding the percent sign (%) in percent-encoded values with its percent-encoded equivalent (%25). For instance, translating the first URL into the second one:&lt;/p&gt;&lt;pre&gt;../../&amp;nbsp; (no encoding)&lt;/pre&gt;&lt;pre&gt;..%2f..%2f&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (single encoding)&lt;/pre&gt;&lt;pre&gt;..%252f..%252f (double encoding)&lt;/pre&gt;&lt;p&gt;Make sure to add a double encoded test case for every attack string you use. For more information about double encoding attacks, read &lt;em&gt;How to - Test for Double Encoding Bugs.&lt;/em&gt;&lt;em&gt;&amp;nbsp;&lt;/em&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;Test through all input points&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Although path manipulation attacks commonly happen through the URL or web forms, it is important to look at additional application input points. Web applications can also take input from client cookies, web methods, extended frameworks (such as Flash/Flex), and third-party APIs (such as Facebook) parameters. Make sure to test for path manipulation in every place where input is taken.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Conclusions&lt;/h1&gt;&lt;p&gt;Path manipulation bugs allow attackers to access a server-side file to execute attacks such as information disclosure and denial of service. They occur because applications don’t properly validate user input against a white list and allow path manipulating characters such as dots and slashes to be processed by the application. To test for this vulnerability you must identify the file path determining variable, commonly sent in the URL or in a web form, and replace it with an attack string while looking for an error message that indicates that the attack string is being used. Finally, to achieve proper test coverage of this bug, be sure to consider double encoding scenarios and to test through all of the application’s input points.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
</guidanceItem>